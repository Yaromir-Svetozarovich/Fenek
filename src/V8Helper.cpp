
#include "V8Helper.h"

#include <iostream>
#include <fstream>
#include <vector>
#include <chrono>
#include <regex>
#include <thread>

#include "GL\glew.h"
#include "GLFW\glfw3.h"

#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

#include "Application.h"
#include "Shader.h"
#include "ComputeShader.h"
#include "V8Shader.h"
#include "V8ComputeShader.h"
#include "V8File.h"
//#include "LASLoader.h"

using std::vector;
using std::cout;
using std::endl;
using std::regex;
using std::smatch;
using std::regex_match;
using std::ssub_match;

V8Helper *V8Helper::_instance = new V8Helper();

static long long start_time = std::chrono::high_resolution_clock::now().time_since_epoch().count();

typedef v8::Persistent<Function, v8::CopyablePersistentTraits<v8::Function>> PersistentFunction;

Local<v8::Script> V8Helper::compileScript(string command) {

	auto source = String::NewFromUtf8(isolate, command.c_str(), NewStringType::kNormal).ToLocalChecked();
	auto script = Script::Compile(context, source);
	//if (script.IsEmpty()) {
	//	return;
	//}

	auto lscript = script.ToLocalChecked();
	//auto result = lscript->Run(context);

	return lscript;
}

void V8Helper::runScriptSilent(string command) {

	auto source = String::NewFromUtf8(isolate, command.c_str(), NewStringType::kNormal).ToLocalChecked();
	auto script = Script::Compile(context, source);
	if (script.IsEmpty()) {
		return;
	}

	auto lscript = script.ToLocalChecked();
	auto result = lscript->Run(context);

}

int getErrorLine(string traceStr) {

	std::istringstream ss(traceStr.c_str());

	regex pattern(".*at .*:(\\d*):.\\d*");
	smatch result;

	string line;
	while (getline(ss, line, '\n')) {
		if (regex_match(line, result, pattern)) {
			ssub_match match_line = result[1];
			int line = std::stoi(match_line);

			return line - 1;
		} else {

		}
	}

	return -1;
}

string getNumberedLines(string str, int first, int last) {

	std::istringstream ss(str.c_str());

	string result = "";

	int i = 0;
	string line;
	while (getline(ss, line, '\n')) {

		if (i >= first && i <= last) {
			result = result + std::to_string(i + 1) + ":" + line + "\n";
		}

		i++;
	}

	return result;
}

void V8Helper::runScript(string command) {

	//cout << ">> " << command << endl;

	auto source = String::NewFromUtf8(isolate, command.c_str(),
		NewStringType::kNormal).ToLocalChecked();
	auto script = Script::Compile(context, source);
	if (script.IsEmpty()) {
		cout << "failed to compile script" << endl;
		cout << command << endl;
		return;
	}

	auto lscript = script.ToLocalChecked();

	TryCatch trycatch(isolate);

	auto result = lscript->Run(context);
	if (result.IsEmpty()) {
		cout << "failed to run script" << endl;
		//cout << command << endl;

		Local<Value> exception = trycatch.Exception();
		String::Utf8Value exception_str(exception);

		Local<Value> trace = trycatch.StackTrace();
		String::Utf8Value trace_str(trace);
		
		string exceptionStr = *exception_str;
		string traceStr = *trace_str;

		
		
		cout << "====" << endl;
		//cout << exceptionStr << endl;
		//cout << "====" << endl;
		
		cout << traceStr << endl;
		cout << "====" << endl;

		int line = getErrorLine(traceStr);

		if (line >= 0) {
			string lines = getNumberedLines(command, line - 2, line + 2);
			cout << lines;
		} else {
			cout << ":(" << endl;
		}

		cout << "====" << endl;
		//cout << traceStr << endl;
		//cout << "====" << endl;


		return;
	}

	auto lresult = result.ToLocalChecked();


	String::Utf8Value utf8(lresult);

	if (*utf8 != nullptr) {
		cout << string(*utf8) << endl;
	}
}

unordered_map<string, int> constants;

string ObjectToString(v8::Isolate* isolate, Local<Value> value) {
	String::Utf8Value utf8_value(isolate, value);
	return string(*utf8_value);
}


void V8Helper::setupGL() {

	// Create a template for the global object and set the
	// built-in global functions.
	Local<ObjectTemplate> tpl = ObjectTemplate::New(this->isolate);
	tpl->SetInternalFieldCount(1);

	
#define CREATE_CONSTANT_ACCESSOR( name, value) \
	tpl->SetAccessor(String::NewFromUtf8(isolate, name), [](Local<String> property, const PropertyCallbackInfo<Value>& info) { \
		info.GetReturnValue().Set(value); \
	})


	// ----------------------------
	//
	// this list was taken from and transformed into this form from the glew library,
	// GLEW under MIT: https://github.com/nigels-com/glew#copyright-and-licensing
	//
	// Notepad++:
	// find what:           #define GL_(\w*) (.*)
	// replace with:        CREATE_CONSTANT_ACCESSOR\("\1", \2\);
	//
	// ----------------------------
	
	
	setupV8GLExtBindings(tpl);
	//setupV8GLExtBindings(tpl, constants);

	CREATE_CONSTANT_ACCESSOR("QUERRY_BUFFER", GL_QUERY_BUFFER);

	CREATE_CONSTANT_ACCESSOR("VERSION_1_1", 1);
	CREATE_CONSTANT_ACCESSOR("ZERO", 0);
	CREATE_CONSTANT_ACCESSOR("FALSE", 0);
	CREATE_CONSTANT_ACCESSOR("LOGIC_OP", 0x0BF1);
	CREATE_CONSTANT_ACCESSOR("NONE", 0);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_COMPONENTS", 0x1003);
	CREATE_CONSTANT_ACCESSOR("NO_ERROR", 0);
	CREATE_CONSTANT_ACCESSOR("POINTS", 0x0000);
	CREATE_CONSTANT_ACCESSOR("CURRENT_BIT", 0x00000001);
	CREATE_CONSTANT_ACCESSOR("TRUE", 1);
	CREATE_CONSTANT_ACCESSOR("ONE", 1);
	CREATE_CONSTANT_ACCESSOR("CLIENT_PIXEL_STORE_BIT", 0x00000001);
	CREATE_CONSTANT_ACCESSOR("LINES", 0x0001);
	CREATE_CONSTANT_ACCESSOR("LINE_LOOP", 0x0002);
	CREATE_CONSTANT_ACCESSOR("POINT_BIT", 0x00000002);
	CREATE_CONSTANT_ACCESSOR("CLIENT_VERTEX_ARRAY_BIT", 0x00000002);
	CREATE_CONSTANT_ACCESSOR("LINE_STRIP", 0x0003);
	CREATE_CONSTANT_ACCESSOR("LINE_BIT", 0x00000004);
	CREATE_CONSTANT_ACCESSOR("TRIANGLES", 0x0004);
	CREATE_CONSTANT_ACCESSOR("TRIANGLE_STRIP", 0x0005);
	CREATE_CONSTANT_ACCESSOR("TRIANGLE_FAN", 0x0006);
	CREATE_CONSTANT_ACCESSOR("QUADS", 0x0007);
	CREATE_CONSTANT_ACCESSOR("QUAD_STRIP", 0x0008);
	CREATE_CONSTANT_ACCESSOR("POLYGON_BIT", 0x00000008);
	CREATE_CONSTANT_ACCESSOR("POLYGON", 0x0009);
	CREATE_CONSTANT_ACCESSOR("POLYGON_STIPPLE_BIT", 0x00000010);
	CREATE_CONSTANT_ACCESSOR("PIXEL_MODE_BIT", 0x00000020);
	CREATE_CONSTANT_ACCESSOR("LIGHTING_BIT", 0x00000040);
	CREATE_CONSTANT_ACCESSOR("FOG_BIT", 0x00000080);
	CREATE_CONSTANT_ACCESSOR("DEPTH_BUFFER_BIT", 0x00000100);
	CREATE_CONSTANT_ACCESSOR("ACCUM", 0x0100);
	CREATE_CONSTANT_ACCESSOR("LOAD", 0x0101);
	CREATE_CONSTANT_ACCESSOR("RETURN", 0x0102);
	CREATE_CONSTANT_ACCESSOR("MULT", 0x0103);
	CREATE_CONSTANT_ACCESSOR("ADD", 0x0104);
	CREATE_CONSTANT_ACCESSOR("NEVER", 0x0200);
	CREATE_CONSTANT_ACCESSOR("ACCUM_BUFFER_BIT", 0x00000200);
	CREATE_CONSTANT_ACCESSOR("LESS", 0x0201);
	CREATE_CONSTANT_ACCESSOR("EQUAL", 0x0202);
	CREATE_CONSTANT_ACCESSOR("LEQUAL", 0x0203);
	CREATE_CONSTANT_ACCESSOR("GREATER", 0x0204);
	CREATE_CONSTANT_ACCESSOR("NOTEQUAL", 0x0205);
	CREATE_CONSTANT_ACCESSOR("GEQUAL", 0x0206);
	CREATE_CONSTANT_ACCESSOR("ALWAYS", 0x0207);
	CREATE_CONSTANT_ACCESSOR("SRC_COLOR", 0x0300);
	CREATE_CONSTANT_ACCESSOR("ONE_MINUS_SRC_COLOR", 0x0301);
	CREATE_CONSTANT_ACCESSOR("SRC_ALPHA", 0x0302);
	CREATE_CONSTANT_ACCESSOR("ONE_MINUS_SRC_ALPHA", 0x0303);
	CREATE_CONSTANT_ACCESSOR("DST_ALPHA", 0x0304);
	CREATE_CONSTANT_ACCESSOR("ONE_MINUS_DST_ALPHA", 0x0305);
	CREATE_CONSTANT_ACCESSOR("DST_COLOR", 0x0306);
	CREATE_CONSTANT_ACCESSOR("ONE_MINUS_DST_COLOR", 0x0307);
	CREATE_CONSTANT_ACCESSOR("SRC_ALPHA_SATURATE", 0x0308);
	CREATE_CONSTANT_ACCESSOR("STENCIL_BUFFER_BIT", 0x00000400);
	CREATE_CONSTANT_ACCESSOR("FRONT_LEFT", 0x0400);
	CREATE_CONSTANT_ACCESSOR("FRONT_RIGHT", 0x0401);
	CREATE_CONSTANT_ACCESSOR("BACK_LEFT", 0x0402);
	CREATE_CONSTANT_ACCESSOR("BACK_RIGHT", 0x0403);
	CREATE_CONSTANT_ACCESSOR("FRONT", 0x0404);
	CREATE_CONSTANT_ACCESSOR("BACK", 0x0405);
	CREATE_CONSTANT_ACCESSOR("LEFT", 0x0406);
	CREATE_CONSTANT_ACCESSOR("RIGHT", 0x0407);
	CREATE_CONSTANT_ACCESSOR("FRONT_AND_BACK", 0x0408);
	CREATE_CONSTANT_ACCESSOR("AUX0", 0x0409);
	CREATE_CONSTANT_ACCESSOR("AUX1", 0x040A);
	CREATE_CONSTANT_ACCESSOR("AUX2", 0x040B);
	CREATE_CONSTANT_ACCESSOR("AUX3", 0x040C);
	CREATE_CONSTANT_ACCESSOR("INVALID_ENUM", 0x0500);
	CREATE_CONSTANT_ACCESSOR("INVALID_VALUE", 0x0501);
	CREATE_CONSTANT_ACCESSOR("INVALID_OPERATION", 0x0502);
	CREATE_CONSTANT_ACCESSOR("STACK_OVERFLOW", 0x0503);
	CREATE_CONSTANT_ACCESSOR("STACK_UNDERFLOW", 0x0504);
	CREATE_CONSTANT_ACCESSOR("OUT_OF_MEMORY", 0x0505);
	CREATE_CONSTANT_ACCESSOR("2D", 0x0600);
	CREATE_CONSTANT_ACCESSOR("3D", 0x0601);
	CREATE_CONSTANT_ACCESSOR("3D_COLOR", 0x0602);
	CREATE_CONSTANT_ACCESSOR("3D_COLOR_TEXTURE", 0x0603);
	CREATE_CONSTANT_ACCESSOR("4D_COLOR_TEXTURE", 0x0604);
	CREATE_CONSTANT_ACCESSOR("PASS_THROUGH_TOKEN", 0x0700);
	CREATE_CONSTANT_ACCESSOR("POINT_TOKEN", 0x0701);
	CREATE_CONSTANT_ACCESSOR("LINE_TOKEN", 0x0702);
	CREATE_CONSTANT_ACCESSOR("POLYGON_TOKEN", 0x0703);
	CREATE_CONSTANT_ACCESSOR("BITMAP_TOKEN", 0x0704);
	CREATE_CONSTANT_ACCESSOR("DRAW_PIXEL_TOKEN", 0x0705);
	CREATE_CONSTANT_ACCESSOR("COPY_PIXEL_TOKEN", 0x0706);
	CREATE_CONSTANT_ACCESSOR("LINE_RESET_TOKEN", 0x0707);
	CREATE_CONSTANT_ACCESSOR("EXP", 0x0800);
	CREATE_CONSTANT_ACCESSOR("VIEWPORT_BIT", 0x00000800);
	CREATE_CONSTANT_ACCESSOR("EXP2", 0x0801);
	CREATE_CONSTANT_ACCESSOR("CW", 0x0900);
	CREATE_CONSTANT_ACCESSOR("CCW", 0x0901);
	CREATE_CONSTANT_ACCESSOR("COEFF", 0x0A00);
	CREATE_CONSTANT_ACCESSOR("ORDER", 0x0A01);
	CREATE_CONSTANT_ACCESSOR("DOMAIN", 0x0A02);
	CREATE_CONSTANT_ACCESSOR("CURRENT_COLOR", 0x0B00);
	CREATE_CONSTANT_ACCESSOR("CURRENT_INDEX", 0x0B01);
	CREATE_CONSTANT_ACCESSOR("CURRENT_NORMAL", 0x0B02);
	CREATE_CONSTANT_ACCESSOR("CURRENT_TEXTURE_COORDS", 0x0B03);
	CREATE_CONSTANT_ACCESSOR("CURRENT_RASTER_COLOR", 0x0B04);
	CREATE_CONSTANT_ACCESSOR("CURRENT_RASTER_INDEX", 0x0B05);
	CREATE_CONSTANT_ACCESSOR("CURRENT_RASTER_TEXTURE_COORDS", 0x0B06);
	CREATE_CONSTANT_ACCESSOR("CURRENT_RASTER_POSITION", 0x0B07);
	CREATE_CONSTANT_ACCESSOR("CURRENT_RASTER_POSITION_VALID", 0x0B08);
	CREATE_CONSTANT_ACCESSOR("CURRENT_RASTER_DISTANCE", 0x0B09);
	CREATE_CONSTANT_ACCESSOR("POINT_SMOOTH", 0x0B10);
	CREATE_CONSTANT_ACCESSOR("POINT_SIZE", 0x0B11);
	CREATE_CONSTANT_ACCESSOR("POINT_SIZE_RANGE", 0x0B12);
	CREATE_CONSTANT_ACCESSOR("POINT_SIZE_GRANULARITY", 0x0B13);
	CREATE_CONSTANT_ACCESSOR("LINE_SMOOTH", 0x0B20);
	CREATE_CONSTANT_ACCESSOR("LINE_WIDTH", 0x0B21);
	CREATE_CONSTANT_ACCESSOR("LINE_WIDTH_RANGE", 0x0B22);
	CREATE_CONSTANT_ACCESSOR("LINE_WIDTH_GRANULARITY", 0x0B23);
	CREATE_CONSTANT_ACCESSOR("LINE_STIPPLE", 0x0B24);
	CREATE_CONSTANT_ACCESSOR("LINE_STIPPLE_PATTERN", 0x0B25);
	CREATE_CONSTANT_ACCESSOR("LINE_STIPPLE_REPEAT", 0x0B26);
	CREATE_CONSTANT_ACCESSOR("LIST_MODE", 0x0B30);
	CREATE_CONSTANT_ACCESSOR("MAX_LIST_NESTING", 0x0B31);
	CREATE_CONSTANT_ACCESSOR("LIST_BASE", 0x0B32);
	CREATE_CONSTANT_ACCESSOR("LIST_INDEX", 0x0B33);
	CREATE_CONSTANT_ACCESSOR("POLYGON_MODE", 0x0B40);
	CREATE_CONSTANT_ACCESSOR("POLYGON_SMOOTH", 0x0B41);
	CREATE_CONSTANT_ACCESSOR("POLYGON_STIPPLE", 0x0B42);
	CREATE_CONSTANT_ACCESSOR("EDGE_FLAG", 0x0B43);
	CREATE_CONSTANT_ACCESSOR("CULL_FACE", 0x0B44);
	CREATE_CONSTANT_ACCESSOR("CULL_FACE_MODE", 0x0B45);
	CREATE_CONSTANT_ACCESSOR("FRONT_FACE", 0x0B46);
	CREATE_CONSTANT_ACCESSOR("LIGHTING", 0x0B50);
	CREATE_CONSTANT_ACCESSOR("LIGHT_MODEL_LOCAL_VIEWER", 0x0B51);
	CREATE_CONSTANT_ACCESSOR("LIGHT_MODEL_TWO_SIDE", 0x0B52);
	CREATE_CONSTANT_ACCESSOR("LIGHT_MODEL_AMBIENT", 0x0B53);
	CREATE_CONSTANT_ACCESSOR("SHADE_MODEL", 0x0B54);
	CREATE_CONSTANT_ACCESSOR("COLOR_MATERIAL_FACE", 0x0B55);
	CREATE_CONSTANT_ACCESSOR("COLOR_MATERIAL_PARAMETER", 0x0B56);
	CREATE_CONSTANT_ACCESSOR("COLOR_MATERIAL", 0x0B57);
	CREATE_CONSTANT_ACCESSOR("FOG", 0x0B60);
	CREATE_CONSTANT_ACCESSOR("FOG_INDEX", 0x0B61);
	CREATE_CONSTANT_ACCESSOR("FOG_DENSITY", 0x0B62);
	CREATE_CONSTANT_ACCESSOR("FOG_START", 0x0B63);
	CREATE_CONSTANT_ACCESSOR("FOG_END", 0x0B64);
	CREATE_CONSTANT_ACCESSOR("FOG_MODE", 0x0B65);
	CREATE_CONSTANT_ACCESSOR("FOG_COLOR", 0x0B66);
	CREATE_CONSTANT_ACCESSOR("DEPTH_RANGE", 0x0B70);
	CREATE_CONSTANT_ACCESSOR("DEPTH_TEST", 0x0B71);
	CREATE_CONSTANT_ACCESSOR("DEPTH_WRITEMASK", 0x0B72);
	CREATE_CONSTANT_ACCESSOR("DEPTH_CLEAR_VALUE", 0x0B73);
	CREATE_CONSTANT_ACCESSOR("DEPTH_FUNC", 0x0B74);
	CREATE_CONSTANT_ACCESSOR("ACCUM_CLEAR_VALUE", 0x0B80);
	CREATE_CONSTANT_ACCESSOR("STENCIL_TEST", 0x0B90);
	CREATE_CONSTANT_ACCESSOR("STENCIL_CLEAR_VALUE", 0x0B91);
	CREATE_CONSTANT_ACCESSOR("STENCIL_FUNC", 0x0B92);
	CREATE_CONSTANT_ACCESSOR("STENCIL_VALUE_MASK", 0x0B93);
	CREATE_CONSTANT_ACCESSOR("STENCIL_FAIL", 0x0B94);
	CREATE_CONSTANT_ACCESSOR("STENCIL_PASS_DEPTH_FAIL", 0x0B95);
	CREATE_CONSTANT_ACCESSOR("STENCIL_PASS_DEPTH_PASS", 0x0B96);
	CREATE_CONSTANT_ACCESSOR("STENCIL_REF", 0x0B97);
	CREATE_CONSTANT_ACCESSOR("STENCIL_WRITEMASK", 0x0B98);
	CREATE_CONSTANT_ACCESSOR("MATRIX_MODE", 0x0BA0);
	CREATE_CONSTANT_ACCESSOR("NORMALIZE", 0x0BA1);
	CREATE_CONSTANT_ACCESSOR("VIEWPORT", 0x0BA2);
	CREATE_CONSTANT_ACCESSOR("MODELVIEW_STACK_DEPTH", 0x0BA3);
	CREATE_CONSTANT_ACCESSOR("PROJECTION_STACK_DEPTH", 0x0BA4);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_STACK_DEPTH", 0x0BA5);
	CREATE_CONSTANT_ACCESSOR("MODELVIEW_MATRIX", 0x0BA6);
	CREATE_CONSTANT_ACCESSOR("PROJECTION_MATRIX", 0x0BA7);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_MATRIX", 0x0BA8);
	CREATE_CONSTANT_ACCESSOR("ATTRIB_STACK_DEPTH", 0x0BB0);
	CREATE_CONSTANT_ACCESSOR("CLIENT_ATTRIB_STACK_DEPTH", 0x0BB1);
	CREATE_CONSTANT_ACCESSOR("ALPHA_TEST", 0x0BC0);
	CREATE_CONSTANT_ACCESSOR("ALPHA_TEST_FUNC", 0x0BC1);
	CREATE_CONSTANT_ACCESSOR("ALPHA_TEST_REF", 0x0BC2);
	CREATE_CONSTANT_ACCESSOR("DITHER", 0x0BD0);
	CREATE_CONSTANT_ACCESSOR("BLEND_DST", 0x0BE0);
	CREATE_CONSTANT_ACCESSOR("BLEND_SRC", 0x0BE1);
	CREATE_CONSTANT_ACCESSOR("BLEND", 0x0BE2);
	CREATE_CONSTANT_ACCESSOR("LOGIC_OP_MODE", 0x0BF0);
	CREATE_CONSTANT_ACCESSOR("INDEX_LOGIC_OP", 0x0BF1);
	CREATE_CONSTANT_ACCESSOR("COLOR_LOGIC_OP", 0x0BF2);
	CREATE_CONSTANT_ACCESSOR("AUX_BUFFERS", 0x0C00);
	CREATE_CONSTANT_ACCESSOR("DRAW_BUFFER", 0x0C01);
	CREATE_CONSTANT_ACCESSOR("READ_BUFFER", 0x0C02);
	CREATE_CONSTANT_ACCESSOR("SCISSOR_BOX", 0x0C10);
	CREATE_CONSTANT_ACCESSOR("SCISSOR_TEST", 0x0C11);
	CREATE_CONSTANT_ACCESSOR("INDEX_CLEAR_VALUE", 0x0C20);
	CREATE_CONSTANT_ACCESSOR("INDEX_WRITEMASK", 0x0C21);
	CREATE_CONSTANT_ACCESSOR("COLOR_CLEAR_VALUE", 0x0C22);
	CREATE_CONSTANT_ACCESSOR("COLOR_WRITEMASK", 0x0C23);
	CREATE_CONSTANT_ACCESSOR("INDEX_MODE", 0x0C30);
	CREATE_CONSTANT_ACCESSOR("RGBA_MODE", 0x0C31);
	CREATE_CONSTANT_ACCESSOR("DOUBLEBUFFER", 0x0C32);
	CREATE_CONSTANT_ACCESSOR("STEREO", 0x0C33);
	CREATE_CONSTANT_ACCESSOR("RENDER_MODE", 0x0C40);
	CREATE_CONSTANT_ACCESSOR("PERSPECTIVE_CORRECTION_HINT", 0x0C50);
	CREATE_CONSTANT_ACCESSOR("POINT_SMOOTH_HINT", 0x0C51);
	CREATE_CONSTANT_ACCESSOR("LINE_SMOOTH_HINT", 0x0C52);
	CREATE_CONSTANT_ACCESSOR("POLYGON_SMOOTH_HINT", 0x0C53);
	CREATE_CONSTANT_ACCESSOR("FOG_HINT", 0x0C54);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_GEN_S", 0x0C60);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_GEN_T", 0x0C61);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_GEN_R", 0x0C62);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_GEN_Q", 0x0C63);
	CREATE_CONSTANT_ACCESSOR("PIXEL_MAP_I_TO_I", 0x0C70);
	CREATE_CONSTANT_ACCESSOR("PIXEL_MAP_S_TO_S", 0x0C71);
	CREATE_CONSTANT_ACCESSOR("PIXEL_MAP_I_TO_R", 0x0C72);
	CREATE_CONSTANT_ACCESSOR("PIXEL_MAP_I_TO_G", 0x0C73);
	CREATE_CONSTANT_ACCESSOR("PIXEL_MAP_I_TO_B", 0x0C74);
	CREATE_CONSTANT_ACCESSOR("PIXEL_MAP_I_TO_A", 0x0C75);
	CREATE_CONSTANT_ACCESSOR("PIXEL_MAP_R_TO_R", 0x0C76);
	CREATE_CONSTANT_ACCESSOR("PIXEL_MAP_G_TO_G", 0x0C77);
	CREATE_CONSTANT_ACCESSOR("PIXEL_MAP_B_TO_B", 0x0C78);
	CREATE_CONSTANT_ACCESSOR("PIXEL_MAP_A_TO_A", 0x0C79);
	CREATE_CONSTANT_ACCESSOR("PIXEL_MAP_I_TO_I_SIZE", 0x0CB0);
	CREATE_CONSTANT_ACCESSOR("PIXEL_MAP_S_TO_S_SIZE", 0x0CB1);
	CREATE_CONSTANT_ACCESSOR("PIXEL_MAP_I_TO_R_SIZE", 0x0CB2);
	CREATE_CONSTANT_ACCESSOR("PIXEL_MAP_I_TO_G_SIZE", 0x0CB3);
	CREATE_CONSTANT_ACCESSOR("PIXEL_MAP_I_TO_B_SIZE", 0x0CB4);
	CREATE_CONSTANT_ACCESSOR("PIXEL_MAP_I_TO_A_SIZE", 0x0CB5);
	CREATE_CONSTANT_ACCESSOR("PIXEL_MAP_R_TO_R_SIZE", 0x0CB6);
	CREATE_CONSTANT_ACCESSOR("PIXEL_MAP_G_TO_G_SIZE", 0x0CB7);
	CREATE_CONSTANT_ACCESSOR("PIXEL_MAP_B_TO_B_SIZE", 0x0CB8);
	CREATE_CONSTANT_ACCESSOR("PIXEL_MAP_A_TO_A_SIZE", 0x0CB9);
	CREATE_CONSTANT_ACCESSOR("UNPACK_SWAP_BYTES", 0x0CF0);
	CREATE_CONSTANT_ACCESSOR("UNPACK_LSB_FIRST", 0x0CF1);
	CREATE_CONSTANT_ACCESSOR("UNPACK_ROW_LENGTH", 0x0CF2);
	CREATE_CONSTANT_ACCESSOR("UNPACK_SKIP_ROWS", 0x0CF3);
	CREATE_CONSTANT_ACCESSOR("UNPACK_SKIP_PIXELS", 0x0CF4);
	CREATE_CONSTANT_ACCESSOR("UNPACK_ALIGNMENT", 0x0CF5);
	CREATE_CONSTANT_ACCESSOR("PACK_SWAP_BYTES", 0x0D00);
	CREATE_CONSTANT_ACCESSOR("PACK_LSB_FIRST", 0x0D01);
	CREATE_CONSTANT_ACCESSOR("PACK_ROW_LENGTH", 0x0D02);
	CREATE_CONSTANT_ACCESSOR("PACK_SKIP_ROWS", 0x0D03);
	CREATE_CONSTANT_ACCESSOR("PACK_SKIP_PIXELS", 0x0D04);
	CREATE_CONSTANT_ACCESSOR("PACK_ALIGNMENT", 0x0D05);
	CREATE_CONSTANT_ACCESSOR("MAP_COLOR", 0x0D10);
	CREATE_CONSTANT_ACCESSOR("MAP_STENCIL", 0x0D11);
	CREATE_CONSTANT_ACCESSOR("INDEX_SHIFT", 0x0D12);
	CREATE_CONSTANT_ACCESSOR("INDEX_OFFSET", 0x0D13);
	CREATE_CONSTANT_ACCESSOR("RED_SCALE", 0x0D14);
	CREATE_CONSTANT_ACCESSOR("RED_BIAS", 0x0D15);
	CREATE_CONSTANT_ACCESSOR("ZOOM_X", 0x0D16);
	CREATE_CONSTANT_ACCESSOR("ZOOM_Y", 0x0D17);
	CREATE_CONSTANT_ACCESSOR("GREEN_SCALE", 0x0D18);
	CREATE_CONSTANT_ACCESSOR("GREEN_BIAS", 0x0D19);
	CREATE_CONSTANT_ACCESSOR("BLUE_SCALE", 0x0D1A);
	CREATE_CONSTANT_ACCESSOR("BLUE_BIAS", 0x0D1B);
	CREATE_CONSTANT_ACCESSOR("ALPHA_SCALE", 0x0D1C);
	CREATE_CONSTANT_ACCESSOR("ALPHA_BIAS", 0x0D1D);
	CREATE_CONSTANT_ACCESSOR("DEPTH_SCALE", 0x0D1E);
	CREATE_CONSTANT_ACCESSOR("DEPTH_BIAS", 0x0D1F);
	CREATE_CONSTANT_ACCESSOR("MAX_EVAL_ORDER", 0x0D30);
	CREATE_CONSTANT_ACCESSOR("MAX_LIGHTS", 0x0D31);
	CREATE_CONSTANT_ACCESSOR("MAX_CLIP_PLANES", 0x0D32);
	CREATE_CONSTANT_ACCESSOR("MAX_TEXTURE_SIZE", 0x0D33);
	CREATE_CONSTANT_ACCESSOR("MAX_PIXEL_MAP_TABLE", 0x0D34);
	CREATE_CONSTANT_ACCESSOR("MAX_ATTRIB_STACK_DEPTH", 0x0D35);
	CREATE_CONSTANT_ACCESSOR("MAX_MODELVIEW_STACK_DEPTH", 0x0D36);
	CREATE_CONSTANT_ACCESSOR("MAX_NAME_STACK_DEPTH", 0x0D37);
	CREATE_CONSTANT_ACCESSOR("MAX_PROJECTION_STACK_DEPTH", 0x0D38);
	CREATE_CONSTANT_ACCESSOR("MAX_TEXTURE_STACK_DEPTH", 0x0D39);
	CREATE_CONSTANT_ACCESSOR("MAX_VIEWPORT_DIMS", 0x0D3A);
	CREATE_CONSTANT_ACCESSOR("MAX_CLIENT_ATTRIB_STACK_DEPTH", 0x0D3B);
	CREATE_CONSTANT_ACCESSOR("SUBPIXEL_BITS", 0x0D50);
	CREATE_CONSTANT_ACCESSOR("INDEX_BITS", 0x0D51);
	CREATE_CONSTANT_ACCESSOR("RED_BITS", 0x0D52);
	CREATE_CONSTANT_ACCESSOR("GREEN_BITS", 0x0D53);
	CREATE_CONSTANT_ACCESSOR("BLUE_BITS", 0x0D54);
	CREATE_CONSTANT_ACCESSOR("ALPHA_BITS", 0x0D55);
	CREATE_CONSTANT_ACCESSOR("DEPTH_BITS", 0x0D56);
	CREATE_CONSTANT_ACCESSOR("STENCIL_BITS", 0x0D57);
	CREATE_CONSTANT_ACCESSOR("ACCUM_RED_BITS", 0x0D58);
	CREATE_CONSTANT_ACCESSOR("ACCUM_GREEN_BITS", 0x0D59);
	CREATE_CONSTANT_ACCESSOR("ACCUM_BLUE_BITS", 0x0D5A);
	CREATE_CONSTANT_ACCESSOR("ACCUM_ALPHA_BITS", 0x0D5B);
	CREATE_CONSTANT_ACCESSOR("NAME_STACK_DEPTH", 0x0D70);
	CREATE_CONSTANT_ACCESSOR("AUTO_NORMAL", 0x0D80);
	CREATE_CONSTANT_ACCESSOR("MAP1_COLOR_4", 0x0D90);
	CREATE_CONSTANT_ACCESSOR("MAP1_INDEX", 0x0D91);
	CREATE_CONSTANT_ACCESSOR("MAP1_NORMAL", 0x0D92);
	CREATE_CONSTANT_ACCESSOR("MAP1_TEXTURE_COORD_1", 0x0D93);
	CREATE_CONSTANT_ACCESSOR("MAP1_TEXTURE_COORD_2", 0x0D94);
	CREATE_CONSTANT_ACCESSOR("MAP1_TEXTURE_COORD_3", 0x0D95);
	CREATE_CONSTANT_ACCESSOR("MAP1_TEXTURE_COORD_4", 0x0D96);
	CREATE_CONSTANT_ACCESSOR("MAP1_VERTEX_3", 0x0D97);
	CREATE_CONSTANT_ACCESSOR("MAP1_VERTEX_4", 0x0D98);
	CREATE_CONSTANT_ACCESSOR("MAP2_COLOR_4", 0x0DB0);
	CREATE_CONSTANT_ACCESSOR("MAP2_INDEX", 0x0DB1);
	CREATE_CONSTANT_ACCESSOR("MAP2_NORMAL", 0x0DB2);
	CREATE_CONSTANT_ACCESSOR("MAP2_TEXTURE_COORD_1", 0x0DB3);
	CREATE_CONSTANT_ACCESSOR("MAP2_TEXTURE_COORD_2", 0x0DB4);
	CREATE_CONSTANT_ACCESSOR("MAP2_TEXTURE_COORD_3", 0x0DB5);
	CREATE_CONSTANT_ACCESSOR("MAP2_TEXTURE_COORD_4", 0x0DB6);
	CREATE_CONSTANT_ACCESSOR("MAP2_VERTEX_3", 0x0DB7);
	CREATE_CONSTANT_ACCESSOR("MAP2_VERTEX_4", 0x0DB8);
	CREATE_CONSTANT_ACCESSOR("MAP1_GRID_DOMAIN", 0x0DD0);
	CREATE_CONSTANT_ACCESSOR("MAP1_GRID_SEGMENTS", 0x0DD1);
	CREATE_CONSTANT_ACCESSOR("MAP2_GRID_DOMAIN", 0x0DD2);
	CREATE_CONSTANT_ACCESSOR("MAP2_GRID_SEGMENTS", 0x0DD3);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_1D", 0x0DE0);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_2D", 0x0DE1);
	CREATE_CONSTANT_ACCESSOR("FEEDBACK_BUFFER_POINTER", 0x0DF0);
	CREATE_CONSTANT_ACCESSOR("FEEDBACK_BUFFER_SIZE", 0x0DF1);
	CREATE_CONSTANT_ACCESSOR("FEEDBACK_BUFFER_TYPE", 0x0DF2);
	CREATE_CONSTANT_ACCESSOR("SELECTION_BUFFER_POINTER", 0x0DF3);
	CREATE_CONSTANT_ACCESSOR("SELECTION_BUFFER_SIZE", 0x0DF4);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_WIDTH", 0x1000);
	CREATE_CONSTANT_ACCESSOR("TRANSFORM_BIT", 0x00001000);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_HEIGHT", 0x1001);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_INTERNAL_FORMAT", 0x1003);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_BORDER_COLOR", 0x1004);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_BORDER", 0x1005);
	CREATE_CONSTANT_ACCESSOR("DONT_CARE", 0x1100);
	CREATE_CONSTANT_ACCESSOR("FASTEST", 0x1101);
	CREATE_CONSTANT_ACCESSOR("NICEST", 0x1102);
	CREATE_CONSTANT_ACCESSOR("AMBIENT", 0x1200);
	CREATE_CONSTANT_ACCESSOR("DIFFUSE", 0x1201);
	CREATE_CONSTANT_ACCESSOR("SPECULAR", 0x1202);
	CREATE_CONSTANT_ACCESSOR("POSITION", 0x1203);
	CREATE_CONSTANT_ACCESSOR("SPOT_DIRECTION", 0x1204);
	CREATE_CONSTANT_ACCESSOR("SPOT_EXPONENT", 0x1205);
	CREATE_CONSTANT_ACCESSOR("SPOT_CUTOFF", 0x1206);
	CREATE_CONSTANT_ACCESSOR("CONSTANT_ATTENUATION", 0x1207);
	CREATE_CONSTANT_ACCESSOR("LINEAR_ATTENUATION", 0x1208);
	CREATE_CONSTANT_ACCESSOR("QUADRATIC_ATTENUATION", 0x1209);
	CREATE_CONSTANT_ACCESSOR("COMPILE", 0x1300);
	CREATE_CONSTANT_ACCESSOR("COMPILE_AND_EXECUTE", 0x1301);
	CREATE_CONSTANT_ACCESSOR("BYTE", 0x1400);
	CREATE_CONSTANT_ACCESSOR("UNSIGNED_BYTE", 0x1401);
	CREATE_CONSTANT_ACCESSOR("SHORT", 0x1402);
	CREATE_CONSTANT_ACCESSOR("UNSIGNED_SHORT", 0x1403);
	CREATE_CONSTANT_ACCESSOR("INT", 0x1404);
	CREATE_CONSTANT_ACCESSOR("UNSIGNED_INT", 0x1405);
	CREATE_CONSTANT_ACCESSOR("FLOAT", 0x1406);
	CREATE_CONSTANT_ACCESSOR("2_BYTES", 0x1407);
	CREATE_CONSTANT_ACCESSOR("3_BYTES", 0x1408);
	CREATE_CONSTANT_ACCESSOR("4_BYTES", 0x1409);
	CREATE_CONSTANT_ACCESSOR("DOUBLE", 0x140A);
	CREATE_CONSTANT_ACCESSOR("CLEAR", 0x1500);
	CREATE_CONSTANT_ACCESSOR("AND", 0x1501);
	CREATE_CONSTANT_ACCESSOR("AND_REVERSE", 0x1502);
	CREATE_CONSTANT_ACCESSOR("COPY", 0x1503);
	CREATE_CONSTANT_ACCESSOR("AND_INVERTED", 0x1504);
	CREATE_CONSTANT_ACCESSOR("NOOP", 0x1505);
	CREATE_CONSTANT_ACCESSOR("XOR", 0x1506);
	CREATE_CONSTANT_ACCESSOR("OR", 0x1507);
	CREATE_CONSTANT_ACCESSOR("NOR", 0x1508);
	CREATE_CONSTANT_ACCESSOR("EQUIV", 0x1509);
	CREATE_CONSTANT_ACCESSOR("INVERT", 0x150A);
	CREATE_CONSTANT_ACCESSOR("OR_REVERSE", 0x150B);
	CREATE_CONSTANT_ACCESSOR("COPY_INVERTED", 0x150C);
	CREATE_CONSTANT_ACCESSOR("OR_INVERTED", 0x150D);
	CREATE_CONSTANT_ACCESSOR("NAND", 0x150E);
	CREATE_CONSTANT_ACCESSOR("SET", 0x150F);
	CREATE_CONSTANT_ACCESSOR("EMISSION", 0x1600);
	CREATE_CONSTANT_ACCESSOR("SHININESS", 0x1601);
	CREATE_CONSTANT_ACCESSOR("AMBIENT_AND_DIFFUSE", 0x1602);
	CREATE_CONSTANT_ACCESSOR("COLOR_INDEXES", 0x1603);
	CREATE_CONSTANT_ACCESSOR("MODELVIEW", 0x1700);
	CREATE_CONSTANT_ACCESSOR("PROJECTION", 0x1701);
	CREATE_CONSTANT_ACCESSOR("TEXTURE", 0x1702);
	CREATE_CONSTANT_ACCESSOR("COLOR", 0x1800);
	CREATE_CONSTANT_ACCESSOR("DEPTH", 0x1801);
	CREATE_CONSTANT_ACCESSOR("STENCIL", 0x1802);
	CREATE_CONSTANT_ACCESSOR("COLOR_INDEX", 0x1900);
	CREATE_CONSTANT_ACCESSOR("STENCIL_INDEX", 0x1901);
	CREATE_CONSTANT_ACCESSOR("DEPTH_COMPONENT", 0x1902);
	CREATE_CONSTANT_ACCESSOR("RED", 0x1903);
	CREATE_CONSTANT_ACCESSOR("GREEN", 0x1904);
	CREATE_CONSTANT_ACCESSOR("BLUE", 0x1905);
	CREATE_CONSTANT_ACCESSOR("ALPHA", 0x1906);
	CREATE_CONSTANT_ACCESSOR("RGB", 0x1907);
	CREATE_CONSTANT_ACCESSOR("RGBA", 0x1908);
	CREATE_CONSTANT_ACCESSOR("LUMINANCE", 0x1909);
	CREATE_CONSTANT_ACCESSOR("LUMINANCE_ALPHA", 0x190A);
	CREATE_CONSTANT_ACCESSOR("BITMAP", 0x1A00);
	CREATE_CONSTANT_ACCESSOR("POINT", 0x1B00);
	CREATE_CONSTANT_ACCESSOR("LINE", 0x1B01);
	CREATE_CONSTANT_ACCESSOR("FILL", 0x1B02);
	CREATE_CONSTANT_ACCESSOR("RENDER", 0x1C00);
	CREATE_CONSTANT_ACCESSOR("FEEDBACK", 0x1C01);
	CREATE_CONSTANT_ACCESSOR("SELECT", 0x1C02);
	CREATE_CONSTANT_ACCESSOR("FLAT", 0x1D00);
	CREATE_CONSTANT_ACCESSOR("SMOOTH", 0x1D01);
	CREATE_CONSTANT_ACCESSOR("KEEP", 0x1E00);
	CREATE_CONSTANT_ACCESSOR("REPLACE", 0x1E01);
	CREATE_CONSTANT_ACCESSOR("INCR", 0x1E02);
	CREATE_CONSTANT_ACCESSOR("DECR", 0x1E03);
	CREATE_CONSTANT_ACCESSOR("VENDOR", 0x1F00);
	CREATE_CONSTANT_ACCESSOR("RENDERER", 0x1F01);
	CREATE_CONSTANT_ACCESSOR("VERSION", 0x1F02);
	CREATE_CONSTANT_ACCESSOR("EXTENSIONS", 0x1F03);
	CREATE_CONSTANT_ACCESSOR("S", 0x2000);
	CREATE_CONSTANT_ACCESSOR("ENABLE_BIT", 0x00002000);
	CREATE_CONSTANT_ACCESSOR("T", 0x2001);
	CREATE_CONSTANT_ACCESSOR("R", 0x2002);
	CREATE_CONSTANT_ACCESSOR("Q", 0x2003);
	CREATE_CONSTANT_ACCESSOR("MODULATE", 0x2100);
	CREATE_CONSTANT_ACCESSOR("DECAL", 0x2101);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_ENV_MODE", 0x2200);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_ENV_COLOR", 0x2201);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_ENV", 0x2300);
	CREATE_CONSTANT_ACCESSOR("EYE_LINEAR", 0x2400);
	CREATE_CONSTANT_ACCESSOR("OBJECT_LINEAR", 0x2401);
	CREATE_CONSTANT_ACCESSOR("SPHERE_MAP", 0x2402);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_GEN_MODE", 0x2500);
	CREATE_CONSTANT_ACCESSOR("OBJECT_PLANE", 0x2501);
	CREATE_CONSTANT_ACCESSOR("EYE_PLANE", 0x2502);
	CREATE_CONSTANT_ACCESSOR("NEAREST", 0x2600);
	CREATE_CONSTANT_ACCESSOR("LINEAR", 0x2601);
	CREATE_CONSTANT_ACCESSOR("NEAREST_MIPMAP_NEAREST", 0x2700);
	CREATE_CONSTANT_ACCESSOR("LINEAR_MIPMAP_NEAREST", 0x2701);
	CREATE_CONSTANT_ACCESSOR("NEAREST_MIPMAP_LINEAR", 0x2702);
	CREATE_CONSTANT_ACCESSOR("LINEAR_MIPMAP_LINEAR", 0x2703);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_MAG_FILTER", 0x2800);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_MIN_FILTER", 0x2801);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_WRAP_S", 0x2802);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_WRAP_T", 0x2803);
	CREATE_CONSTANT_ACCESSOR("CLAMP", 0x2900);
	CREATE_CONSTANT_ACCESSOR("REPEAT", 0x2901);
	CREATE_CONSTANT_ACCESSOR("POLYGON_OFFSET_UNITS", 0x2A00);
	CREATE_CONSTANT_ACCESSOR("POLYGON_OFFSET_POINT", 0x2A01);
	CREATE_CONSTANT_ACCESSOR("POLYGON_OFFSET_LINE", 0x2A02);
	CREATE_CONSTANT_ACCESSOR("R3_G3_B2", 0x2A10);
	CREATE_CONSTANT_ACCESSOR("V2F", 0x2A20);
	CREATE_CONSTANT_ACCESSOR("V3F", 0x2A21);
	CREATE_CONSTANT_ACCESSOR("C4UB_V2F", 0x2A22);
	CREATE_CONSTANT_ACCESSOR("C4UB_V3F", 0x2A23);
	CREATE_CONSTANT_ACCESSOR("C3F_V3F", 0x2A24);
	CREATE_CONSTANT_ACCESSOR("N3F_V3F", 0x2A25);
	CREATE_CONSTANT_ACCESSOR("C4F_N3F_V3F", 0x2A26);
	CREATE_CONSTANT_ACCESSOR("T2F_V3F", 0x2A27);
	CREATE_CONSTANT_ACCESSOR("T4F_V4F", 0x2A28);
	CREATE_CONSTANT_ACCESSOR("T2F_C4UB_V3F", 0x2A29);
	CREATE_CONSTANT_ACCESSOR("T2F_C3F_V3F", 0x2A2A);
	CREATE_CONSTANT_ACCESSOR("T2F_N3F_V3F", 0x2A2B);
	CREATE_CONSTANT_ACCESSOR("T2F_C4F_N3F_V3F", 0x2A2C);
	CREATE_CONSTANT_ACCESSOR("T4F_C4F_N3F_V4F", 0x2A2D);
	CREATE_CONSTANT_ACCESSOR("CLIP_PLANE0", 0x3000);
	CREATE_CONSTANT_ACCESSOR("CLIP_PLANE1", 0x3001);
	CREATE_CONSTANT_ACCESSOR("CLIP_PLANE2", 0x3002);
	CREATE_CONSTANT_ACCESSOR("CLIP_PLANE3", 0x3003);
	CREATE_CONSTANT_ACCESSOR("CLIP_PLANE4", 0x3004);
	CREATE_CONSTANT_ACCESSOR("CLIP_PLANE5", 0x3005);
	CREATE_CONSTANT_ACCESSOR("LIGHT0", 0x4000);
	CREATE_CONSTANT_ACCESSOR("COLOR_BUFFER_BIT", 0x00004000);
	CREATE_CONSTANT_ACCESSOR("LIGHT1", 0x4001);
	CREATE_CONSTANT_ACCESSOR("LIGHT2", 0x4002);
	CREATE_CONSTANT_ACCESSOR("LIGHT3", 0x4003);
	CREATE_CONSTANT_ACCESSOR("LIGHT4", 0x4004);
	CREATE_CONSTANT_ACCESSOR("LIGHT5", 0x4005);
	CREATE_CONSTANT_ACCESSOR("LIGHT6", 0x4006);
	CREATE_CONSTANT_ACCESSOR("LIGHT7", 0x4007);
	CREATE_CONSTANT_ACCESSOR("HINT_BIT", 0x00008000);
	CREATE_CONSTANT_ACCESSOR("POLYGON_OFFSET_FILL", 0x8037);
	CREATE_CONSTANT_ACCESSOR("POLYGON_OFFSET_FACTOR", 0x8038);
	CREATE_CONSTANT_ACCESSOR("ALPHA4", 0x803B);
	CREATE_CONSTANT_ACCESSOR("ALPHA8", 0x803C);
	CREATE_CONSTANT_ACCESSOR("ALPHA12", 0x803D);
	CREATE_CONSTANT_ACCESSOR("ALPHA16", 0x803E);
	CREATE_CONSTANT_ACCESSOR("LUMINANCE4", 0x803F);
	CREATE_CONSTANT_ACCESSOR("LUMINANCE8", 0x8040);
	CREATE_CONSTANT_ACCESSOR("LUMINANCE12", 0x8041);
	CREATE_CONSTANT_ACCESSOR("LUMINANCE16", 0x8042);
	CREATE_CONSTANT_ACCESSOR("LUMINANCE4_ALPHA4", 0x8043);
	CREATE_CONSTANT_ACCESSOR("LUMINANCE6_ALPHA2", 0x8044);
	CREATE_CONSTANT_ACCESSOR("LUMINANCE8_ALPHA8", 0x8045);
	CREATE_CONSTANT_ACCESSOR("LUMINANCE12_ALPHA4", 0x8046);
	CREATE_CONSTANT_ACCESSOR("LUMINANCE12_ALPHA12", 0x8047);
	CREATE_CONSTANT_ACCESSOR("LUMINANCE16_ALPHA16", 0x8048);
	CREATE_CONSTANT_ACCESSOR("INTENSITY", 0x8049);
	CREATE_CONSTANT_ACCESSOR("INTENSITY4", 0x804A);
	CREATE_CONSTANT_ACCESSOR("INTENSITY8", 0x804B);
	CREATE_CONSTANT_ACCESSOR("INTENSITY12", 0x804C);
	CREATE_CONSTANT_ACCESSOR("INTENSITY16", 0x804D);
	CREATE_CONSTANT_ACCESSOR("RGB4", 0x804F);
	CREATE_CONSTANT_ACCESSOR("RGB5", 0x8050);
	CREATE_CONSTANT_ACCESSOR("RGB8", 0x8051);
	CREATE_CONSTANT_ACCESSOR("RGB10", 0x8052);
	CREATE_CONSTANT_ACCESSOR("RGB12", 0x8053);
	CREATE_CONSTANT_ACCESSOR("RGB16", 0x8054);
	CREATE_CONSTANT_ACCESSOR("RGBA2", 0x8055);
	CREATE_CONSTANT_ACCESSOR("RGBA4", 0x8056);
	CREATE_CONSTANT_ACCESSOR("RGB5_A1", 0x8057);
	CREATE_CONSTANT_ACCESSOR("RGBA8", 0x8058);
	CREATE_CONSTANT_ACCESSOR("RGB10_A2", 0x8059);
	CREATE_CONSTANT_ACCESSOR("RGBA12", 0x805A);
	CREATE_CONSTANT_ACCESSOR("RGBA16", 0x805B);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_RED_SIZE", 0x805C);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_GREEN_SIZE", 0x805D);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_BLUE_SIZE", 0x805E);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_ALPHA_SIZE", 0x805F);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_LUMINANCE_SIZE", 0x8060);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_INTENSITY_SIZE", 0x8061);
	CREATE_CONSTANT_ACCESSOR("PROXY_TEXTURE_1D", 0x8063);
	CREATE_CONSTANT_ACCESSOR("PROXY_TEXTURE_2D", 0x8064);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_PRIORITY", 0x8066);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_RESIDENT", 0x8067);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_BINDING_1D", 0x8068);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_BINDING_2D", 0x8069);
	CREATE_CONSTANT_ACCESSOR("VERTEX_ARRAY", 0x8074);
	CREATE_CONSTANT_ACCESSOR("NORMAL_ARRAY", 0x8075);
	CREATE_CONSTANT_ACCESSOR("COLOR_ARRAY", 0x8076);
	CREATE_CONSTANT_ACCESSOR("INDEX_ARRAY", 0x8077);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_COORD_ARRAY", 0x8078);
	CREATE_CONSTANT_ACCESSOR("EDGE_FLAG_ARRAY", 0x8079);
	CREATE_CONSTANT_ACCESSOR("VERTEX_ARRAY_SIZE", 0x807A);
	CREATE_CONSTANT_ACCESSOR("VERTEX_ARRAY_TYPE", 0x807B);
	CREATE_CONSTANT_ACCESSOR("VERTEX_ARRAY_STRIDE", 0x807C);
	CREATE_CONSTANT_ACCESSOR("NORMAL_ARRAY_TYPE", 0x807E);
	CREATE_CONSTANT_ACCESSOR("NORMAL_ARRAY_STRIDE", 0x807F);
	CREATE_CONSTANT_ACCESSOR("COLOR_ARRAY_SIZE", 0x8081);
	CREATE_CONSTANT_ACCESSOR("COLOR_ARRAY_TYPE", 0x8082);
	CREATE_CONSTANT_ACCESSOR("COLOR_ARRAY_STRIDE", 0x8083);
	CREATE_CONSTANT_ACCESSOR("INDEX_ARRAY_TYPE", 0x8085);
	CREATE_CONSTANT_ACCESSOR("INDEX_ARRAY_STRIDE", 0x8086);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_COORD_ARRAY_SIZE", 0x8088);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_COORD_ARRAY_TYPE", 0x8089);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_COORD_ARRAY_STRIDE", 0x808A);
	CREATE_CONSTANT_ACCESSOR("EDGE_FLAG_ARRAY_STRIDE", 0x808C);
	CREATE_CONSTANT_ACCESSOR("VERTEX_ARRAY_POINTER", 0x808E);
	CREATE_CONSTANT_ACCESSOR("NORMAL_ARRAY_POINTER", 0x808F);
	CREATE_CONSTANT_ACCESSOR("COLOR_ARRAY_POINTER", 0x8090);
	CREATE_CONSTANT_ACCESSOR("INDEX_ARRAY_POINTER", 0x8091);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_COORD_ARRAY_POINTER", 0x8092);
	CREATE_CONSTANT_ACCESSOR("EDGE_FLAG_ARRAY_POINTER", 0x8093);
	CREATE_CONSTANT_ACCESSOR("COLOR_INDEX1_EXT", 0x80E2);
	CREATE_CONSTANT_ACCESSOR("COLOR_INDEX2_EXT", 0x80E3);
	CREATE_CONSTANT_ACCESSOR("COLOR_INDEX4_EXT", 0x80E4);
	CREATE_CONSTANT_ACCESSOR("COLOR_INDEX8_EXT", 0x80E5);
	CREATE_CONSTANT_ACCESSOR("COLOR_INDEX12_EXT", 0x80E6);
	CREATE_CONSTANT_ACCESSOR("COLOR_INDEX16_EXT", 0x80E7);
	CREATE_CONSTANT_ACCESSOR("EVAL_BIT", 0x00010000);
	CREATE_CONSTANT_ACCESSOR("LIST_BIT", 0x00020000);
	CREATE_CONSTANT_ACCESSOR("TEXTURE_BIT", 0x00040000);
	CREATE_CONSTANT_ACCESSOR("SCISSOR_BIT", 0x00080000);
	CREATE_CONSTANT_ACCESSOR("ALL_ATTRIB_BITS", 0x000fffff);
	CREATE_CONSTANT_ACCESSOR("CLIENT_ALL_ATTRIB_BITS", 0xffffffff);







	tpl->Set(String::NewFromUtf8(isolate, "uniform1f"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 2) {
			V8Helper::_instance->throwException("uniform1f requires 2 arguments");
			return;
		}

		String::Utf8Value aUniformLocation(args[0]);
		String::Utf8Value aValue(args[1]);

		int uniformLocation = std::stoi(*aUniformLocation);
		float value = std::stof(*aValue);

		glUniform1f(uniformLocation, value);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "uniform2f"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 3) {
			V8Helper::_instance->throwException("uniform2f requires 3 arguments");
			return;
		}

		String::Utf8Value aUniformLocation(args[0]);
		String::Utf8Value aValue1(args[1]);
		String::Utf8Value aValue2(args[2]);

		int uniformLocation = std::stoi(*aUniformLocation);
		float value1 = std::stof(*aValue1);
		float value2 = std::stof(*aValue2);

		glUniform2f(uniformLocation, value1, value2);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "uniform3f"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 4) {
			V8Helper::_instance->throwException("uniform3f requires 4 arguments");
			return;
		}

		String::Utf8Value aUniformLocation(args[0]);
		String::Utf8Value aValue1(args[1]);
		String::Utf8Value aValue2(args[2]);
		String::Utf8Value aValue3(args[3]);

		int uniformLocation = std::stoi(*aUniformLocation);
		float value1 = std::stof(*aValue1);
		float value2 = std::stof(*aValue2);
		float value3 = std::stof(*aValue3);

		glUniform3f(uniformLocation, value1, value2, value3);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "uniform4f"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 5) {
			V8Helper::_instance->throwException("uniform4f requires 5 arguments");
			return;
		}

		String::Utf8Value aUniformLocation(args[0]);
		String::Utf8Value aValue1(args[1]);
		String::Utf8Value aValue2(args[2]);
		String::Utf8Value aValue3(args[3]);
		String::Utf8Value aValue4(args[4]);

		int uniformLocation = std::stoi(*aUniformLocation);
		float value1 = std::stof(*aValue1);
		float value2 = std::stof(*aValue2);
		float value3 = std::stof(*aValue3);
		float value4 = std::stof(*aValue4);

		glUniform4f(uniformLocation, value1, value2, value3, value4);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "uniformMatrix4fv"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 4) {
			V8Helper::_instance->throwException("uniformMatrix4fv requires 4 arguments");
			return;
		}

		String::Utf8Value aUniformLocation(args[0]);
		String::Utf8Value aCount(args[1]);
		String::Utf8Value aTranspose(args[2]);

		int uniformLocation = std::stoi(*aUniformLocation);
		int count = std::stoi(*aCount);
		GLboolean transpose = std::stoi(*aTranspose);

		float *data = nullptr;
		if (args[3]->IsFloat32Array()) {
			v8::Local<v8::Float32Array> view = (args[3]).As<v8::Float32Array>();

			auto buffer = view->Buffer();
			void *bdata = view->Buffer()->GetContents().Data();

			data = reinterpret_cast<float*>(bdata);
		} else {
			cout << "ERROR: array must be of type Float32Array" << endl;
			exit(1);
		}

		glUniformMatrix4fv(uniformLocation, count, transpose, data);
		//glUniform4f(uniformLocation, value1, value2, value3, value4);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "clearColor"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 4) {
			V8Helper::_instance->throwException("clearColor requires 4 arguments");
			return;
		}

		float red = args[0]->NumberValue();
		float green= args[1]->NumberValue();
		float blue = args[2]->NumberValue();
		float alpha = args[3]->NumberValue();

		//cout << key << ": " << value << endl;
		glClearColor(red, green, blue, alpha);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "clearDepth"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("clearDepth requires 1 arguments");
			return;
		}

		double depth = args[0]->NumberValue();

		glClearDepth(depth);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "depthFunc"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("depthFunc requires 1 arguments");
			return;
		}

		GLenum depthFunc = args[0]->Uint32Value();

		glDepthFunc(depthFunc);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "clear"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("clear requires 1 argument");
			return;
		}

		GLbitfield mask = args[0]->Uint32Value();

		glClear(mask);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "createVertexArray"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& info) {
		if (info.Length() != 0) {
			V8Helper::_instance->throwException("createVertexArray requires 0 arguments");
			return;
		}

		GLuint vao = -1;
		glCreateVertexArrays(1, &vao);

		info.GetReturnValue().Set(vao);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "createTexture"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& info) {
		if (info.Length() != 0) {
			V8Helper::_instance->throwException("createTexture requires 0 arguments");
			return;
		}

		GLuint tex = -1;
		glGenTextures(1, &tex);

		info.GetReturnValue().Set(tex);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "deleteTexture"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& info) {
		if (info.Length() != 1) {
			V8Helper::_instance->throwException("deleteTexture requires 1 arguments");
			return;
		}

		GLuint tex = info[0]->Uint32Value();
		glDeleteTextures(1, &tex);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "texImage2D"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 9) {
			V8Helper::_instance->throwException("texImage2D requires 9 arguments");
			return;
		}

		GLenum target = args[0]->Uint32Value();
		GLint level = args[1]->Int32Value();
		GLint internalFormat = args[2]->Int32Value();
		GLsizei width = args[3]->Int32Value();
		GLsizei height = args[4]->Int32Value();
		GLint border = args[5]->Int32Value();
		GLenum format = args[6]->Uint32Value();
		GLenum type = args[7]->Uint32Value();
		
		void* data = nullptr;
		if (args[8]->IsArrayBuffer()) {
			v8::Local<v8::ArrayBuffer> buffer = (args[8]).As<v8::ArrayBuffer>();
			void *bdata = buffer->GetContents().Data();
			data = reinterpret_cast<void*>(bdata);
		} else if (args[8]->IsArrayBufferView()) {
			v8::Local<v8::ArrayBufferView> view = (args[8]).As<v8::ArrayBufferView>();
			auto buffer = view->Buffer();
			void *bdata = view->Buffer()->GetContents().Data();
			data = reinterpret_cast<void*>(bdata);
		} else if (args[8]->IsNumber()) {
			int value = args[8]->NumberValue();
			data = (void*)value;
		} else {
			cout << "ERROR(texImage2D): array must be of type ArrayBuffer" << endl;
			exit(1);
		}

		glTexImage2D(target, level, internalFormat, width, height, border, format, type, data);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "texSubImage2D"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 9) {
			V8Helper::_instance->throwException("texSubImage2D requires 9 arguments");
			return;
		}

		GLenum target = args[0]->Uint32Value();
		GLint level = args[1]->Int32Value();
		GLint xoffset = args[2]->Int32Value();
		GLint yoffset = args[3]->Int32Value();
		GLsizei width = args[4]->Int32Value();
		GLsizei height = args[5]->Int32Value();
		GLenum format = args[6]->Uint32Value();
		GLenum type = args[7]->Uint32Value();

		void* data = nullptr;
		if (args[8]->IsArrayBuffer()) {
			v8::Local<v8::ArrayBuffer> buffer = (args[8]).As<v8::ArrayBuffer>();
			void *bdata = buffer->GetContents().Data();
			data = reinterpret_cast<void*>(bdata);
		} else if (args[8]->IsArrayBufferView()) {
			v8::Local<v8::ArrayBufferView> view = (args[8]).As<v8::ArrayBufferView>();
			auto buffer = view->Buffer();
			void *bdata = view->Buffer()->GetContents().Data();
			data = reinterpret_cast<void*>(bdata);
		} else if (args[8]->IsNumber()) {
			int value = args[8]->NumberValue();
			data = (void*)value;
		} else {
			cout << "ERROR(texImage2D): array must be of type ArrayBuffer" << endl;
			exit(1);
		}

		glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, data);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "multiTexCoord4i"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 5) {
			V8Helper::_instance->throwException("multiTexCoord4i requires 5 arguments");
			return;
		}

		String::Utf8Value targetUTF8(args[0]);
		GLenum target = std::stoul(*targetUTF8);

		String::Utf8Value sUTF8(args[1]);
		GLint s = std::stoi(*sUTF8);

		String::Utf8Value tUTF8(args[2]);
		GLint t = std::stoi(*tUTF8);

		String::Utf8Value rUTF8(args[3]);
		GLint r = std::stoi(*rUTF8);

		String::Utf8Value qUTF8(args[4]);
		GLint q = std::stoi(*qUTF8);



		glMultiTexCoord4i(target, s, t, r, q);

		// args.GetReturnValue().Set(fb);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "createProgram"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& info) {
		if (info.Length() != 0) {
			V8Helper::_instance->throwException("createProgram requires 0 arguments");
			return;
		}

		GLuint program = glCreateProgram();

		info.GetReturnValue().Set(program);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "createShader"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& info) {
		if (info.Length() != 1) {
			V8Helper::_instance->throwException("createShader requires 1 arguments");
			return;
		}

		GLenum shaderType = info[0]->Int32Value();

		GLuint shader = glCreateShader(shaderType);

		info.GetReturnValue().Set(shader);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "shaderSource"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& info) {
		if (info.Length() != 2) {
			V8Helper::_instance->throwException("shaderSource requires 2 arguments");
			return;
		}

		int shader = info[0]->Int32Value();
		String::Utf8Value sourceUTF8(info[1]);
		string source = *sourceUTF8;

		const char* csource = source.c_str();

		// glShaderSource(glshader, 1, &vsc, NULL);
		glShaderSource(shader, 1, &csource, NULL);

		info.GetReturnValue().Set(shader);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "getUniformLocation"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& info) {
		if (info.Length() != 2) {
			V8Helper::_instance->throwException("getUniformLocation requires 2 arguments");
			return;
		}

		int program = info[0]->Int32Value();
		String::Utf8Value nameUTF8(info[1]);
		string name = *nameUTF8;

		const char* cname = name.c_str();

		// glShaderSource(glshader, 1, &vsc, NULL);
		auto id = glGetUniformLocation(program, cname);

		info.GetReturnValue().Set(id);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "getUniformBlockIndex"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& info) {
		if (info.Length() != 2) {
			V8Helper::_instance->throwException("getUniformBlockIndex requires 2 arguments");
			return;
		}

		int program = info[0]->Int32Value();
		String::Utf8Value nameUTF8(info[1]);
		string name = *nameUTF8;
		const char* cname = name.c_str();

		// glShaderSource(glshader, 1, &vsc, NULL);
		auto index = glGetUniformBlockIndex(program, cname);

		info.GetReturnValue().Set(index);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "getError"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& info) {
		if (info.Length() != 0) {
			V8Helper::_instance->throwException("getError requires 0 arguments");
			return;
		}

		int error = glGetError();

		info.GetReturnValue().Set(error);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "createBuffer"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& info) {
		if (info.Length() != 0) {
			V8Helper::_instance->throwException("createBuffer requires 0 arguments");
			return;
		}

		GLuint buffer = -1;
		glCreateBuffers(1, &buffer);

		info.GetReturnValue().Set(buffer);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "bindVertexArray"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("bindVertexArray requires 1 argument");
			return;
		}

		String::Utf8Value handleUTF8(args[0]);

		int handle = std::stoi(*handleUTF8);

		glBindVertexArray(handle);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "glBindBufferBase"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 3) {
			V8Helper::_instance->throwException("glBindBufferBase requires 3 argument");
			return;
		}

		String::Utf8Value targetUTF8(args[0]);
		String::Utf8Value indexUTF8(args[1]);
		String::Utf8Value bufferUTF8(args[2]);

		GLenum target = std::stoi(*targetUTF8);
		GLuint index = std::stoi(*indexUTF8);
		GLuint buffer = std::stoi(*bufferUTF8);

		glBindBufferBase(target, index, buffer);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "bindBuffer"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 2) {
			V8Helper::_instance->throwException("bindBuffer requires 2 argument");
			return;
		}

		String::Utf8Value typeUTF8(args[0]);
		String::Utf8Value handleUTF8(args[1]);

		int type = std::stoi(*typeUTF8);
		int handle = std::stoi(*handleUTF8);

		glBindBuffer(type, handle);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "createFramebuffer"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 0) {
			V8Helper::_instance->throwException("createFramebuffer requires 0 arguments");
			return;
		}

		GLuint fb;
		glGenFramebuffers(1, &fb);

		args.GetReturnValue().Set(fb);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "bindFramebuffer"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 2) {
			V8Helper::_instance->throwException("bindFramebuffer requires 2 argument");
			return;
		}

		String::Utf8Value targetUTF8(args[0]);
		String::Utf8Value framebufferUTF8(args[1]);

		GLenum target = std::stoi(*targetUTF8);
		GLuint framebuffer = std::stoi(*framebufferUTF8);

		glBindFramebuffer(target, framebuffer);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "framebufferTexture2D"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 5) {
			V8Helper::_instance->throwException("framebufferTexture2D requires 5 argument");
			return;
		}
		
		String::Utf8Value targetUTF8(args[0]);
		String::Utf8Value attachmentUTF8(args[1]);
		String::Utf8Value textargetUTF8(args[2]);
		String::Utf8Value textureUTF8(args[3]);
		String::Utf8Value levelUTF8(args[4]);

		GLenum target = std::stoi(*targetUTF8);
		GLenum attachment = std::stoi(*attachmentUTF8);
		GLenum textarget = std::stoi(*textargetUTF8);
		GLuint texture = std::stoi(*textureUTF8);
		GLint level = std::stoi(*levelUTF8);

		glFramebufferTexture2D(target, attachment, textarget, texture, level);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "blitFramebuffer"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 10) {
			V8Helper::_instance->throwException("blitFramebuffer requires 10 argument");
			return;
		}

		String::Utf8Value srcX0UTF8(args[0]);
		String::Utf8Value srcY0UTF8(args[1]);
		String::Utf8Value srcX1UTF8(args[2]);
		String::Utf8Value srcY1UTF8(args[3]);
		String::Utf8Value dstX0UTF8(args[4]);
		String::Utf8Value dstY0UTF8(args[5]);
		String::Utf8Value dstX1UTF8(args[6]);
		String::Utf8Value dstY1UTF8(args[7]);
		String::Utf8Value maskUTF8(args[8]);
		String::Utf8Value filterUTF8(args[9]);

		GLint srcX0 = std::stoi(*srcX0UTF8);
		GLint srcY0 = std::stoi(*srcY0UTF8);
		GLint srcX1 = std::stoi(*srcX1UTF8);
		GLint srcY1 = std::stoi(*srcY1UTF8);
		GLint dstX0 = std::stoi(*srcX0UTF8);
		GLint dstY0 = std::stoi(*srcY0UTF8);
		GLint dstX1 = std::stoi(*srcX1UTF8);
		GLint dstY1 = std::stoi(*srcY1UTF8);
		GLbitfield mask = std::stoi(*maskUTF8);
		GLenum filter = std::stoi(*filterUTF8);

		glBlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "blitNamedFramebuffer"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 12) {
			V8Helper::_instance->throwException("blitNamedFramebuffer requires 12 argument");
			return;
		}

		String::Utf8Value readBufferUTF8(args[0]);
		String::Utf8Value drawBufferUTF8(args[1]);

		String::Utf8Value srcX0UTF8(args[2]);
		String::Utf8Value srcY0UTF8(args[3]);
		String::Utf8Value srcX1UTF8(args[4]);
		String::Utf8Value srcY1UTF8(args[5]);
		String::Utf8Value dstX0UTF8(args[6]);
		String::Utf8Value dstY0UTF8(args[7]);
		String::Utf8Value dstX1UTF8(args[8]);
		String::Utf8Value dstY1UTF8(args[9]);
		String::Utf8Value maskUTF8(args[10]);
		String::Utf8Value filterUTF8(args[11]);


		GLuint readBuffer = std::stoi(*readBufferUTF8);
		GLuint drawBuffer = std::stoi(*drawBufferUTF8);

		GLint srcX0 = std::stoi(*srcX0UTF8);
		GLint srcY0 = std::stoi(*srcY0UTF8);
		GLint srcX1 = std::stoi(*srcX1UTF8);
		GLint srcY1 = std::stoi(*srcY1UTF8);
		GLint dstX0 = std::stoi(*dstX0UTF8);
		GLint dstY0 = std::stoi(*dstY0UTF8);
		GLint dstX1 = std::stoi(*dstX1UTF8);
		GLint dstY1 = std::stoi(*dstY1UTF8);
		GLbitfield mask = std::stoi(*maskUTF8);
		GLenum filter = std::stoi(*filterUTF8);

		glBlitNamedFramebuffer(readBuffer, drawBuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "viewport"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 4) {
			V8Helper::_instance->throwException("viewport requires 4 argument");
			return;
		}

		String::Utf8Value xUTF8(args[0]);
		String::Utf8Value yUTF8(args[1]);
		String::Utf8Value widthUTF8(args[2]);
		String::Utf8Value heightUTF8(args[3]);

		GLint x = std::stoi(*xUTF8);
		GLint y = std::stoi(*yUTF8);
		GLsizei width = std::stoi(*widthUTF8);
		GLsizei height = std::stoi(*heightUTF8);

		glViewport(x, y, width, height);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "bindTextureUnit"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 2) {
			V8Helper::_instance->throwException("bindTextureUnit requires 2 argument");
			return;
		}

		String::Utf8Value unitUTF8(args[0]);
		String::Utf8Value textureUTF8(args[1]);

		GLuint unit = std::stoi(*unitUTF8);
		GLuint texture = std::stoi(*textureUTF8);

		glBindTextureUnit(unit, texture);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "bindImageTexture"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 7) {
			V8Helper::_instance->throwException("bindImageTexture requires 7 argument");
			return;
		}

		String::Utf8Value unitUTF8(args[0]);
		String::Utf8Value textureUTF8(args[1]);
		String::Utf8Value levelUTF8(args[2]);
		String::Utf8Value layeredUTF8(args[3]);
		String::Utf8Value layerUTF8(args[4]);
		String::Utf8Value accessUTF8(args[5]);
		String::Utf8Value formatUTF8(args[6]);

		GLuint unit = std::stoi(*unitUTF8);
		GLuint texture = std::stoi(*textureUTF8);
		GLint level = std::stoi(*levelUTF8);
		GLboolean layered = std::stoi(*layeredUTF8);
		GLint layer = std::stoi(*layerUTF8);
		GLenum access = std::stoi(*accessUTF8);
		GLenum format = std::stoi(*formatUTF8);

		glBindImageTexture(unit, texture, level, layered, layer, access, format);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "dispatchCompute"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 3) {
			V8Helper::_instance->throwException("dispatchCompute requires 3 argument");
			return;
		}

		String::Utf8Value num_groups_xUTF8(args[0]);
		String::Utf8Value num_groups_yUTF8(args[1]);
		String::Utf8Value num_groups_zUTF8(args[2]);

		GLuint num_groups_x = std::stoi(*num_groups_xUTF8);
		GLuint num_groups_y = std::stoi(*num_groups_yUTF8);
		GLuint num_groups_z = std::stoi(*num_groups_zUTF8);

		glDispatchCompute(num_groups_x, num_groups_y, num_groups_z);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "bindTexture"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 2) {
			V8Helper::_instance->throwException("bindTexture requires 2 argument");
			return;
		}

		//String::Utf8Value targetUTF8(args[0]);
		//String::Utf8Value textureUTF8(args[1]);

		//int target = std::stoi(*targetUTF8);
		//int texture = std::stoi(*textureUTF8);

		GLenum target = args[0]->Uint32Value();
		GLuint texture = args[1]->IntegerValue();

		glBindTexture(target, texture);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "activeTexture"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("activeTexture requires 1 argument");
			return;
		}

		String::Utf8Value textureUTF8(args[0]);

		GLenum texture = std::stoi(*textureUTF8);

		glActiveTexture(texture);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "texParameteri"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 3) {
			V8Helper::_instance->throwException("texParameteri requires 3 argument");
			return;
		}

		String::Utf8Value targetUTF8(args[0]);
		String::Utf8Value pnameUTF8(args[1]);
		String::Utf8Value paramUTF8(args[2]);

		GLenum target = std::stoul(*targetUTF8);
		GLenum pname = std::stoul(*pnameUTF8);
		GLint param = std::stoi(*paramUTF8);

		glTexParameteri(target, pname, param);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "bufferData"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 4) {
			V8Helper::_instance->throwException("bufferData requires 4 argument");
			return;
		}

		//String::Utf8Value targetUTF8(args[0]);
		String::Utf8Value sizeUTF8(args[1]);
		String::Utf8Value usageUTF8(args[3]);

		//GLenum target = std::stoi(*targetUTF8);
		GLenum target = args[0]->Uint32Value();
		GLsizeiptr size = args[1]->Uint32Value();
		GLenum usage = args[3]->Uint32Value();

		float *data = nullptr;
		if (args[2]->IsFloat32Array()) {
			v8::Local<v8::Float32Array> view = (args[2]).As<v8::Float32Array>();

			auto buffer = view->Buffer();
			void *bdata = view->Buffer()->GetContents().Data();

			data = reinterpret_cast<float*>(bdata);

		} else {
			//cout << "ERROR: array must be of type Float32Array" << endl;
			//exit(1);
		}

		glBufferData(target, size, data, usage);
	}));

	//tpl->Set(String::NewFromUtf8(isolate, "mapNamedBufferRange"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
	//	if (args.Length() != 4) {
	//		V8Helper::_instance->throwException("bufferData requires 4 argument");
	//		return;
	//	}

	//	//String::Utf8Value targetUTF8(args[0]);
	//	String::Utf8Value sizeUTF8(args[1]);
	//	String::Utf8Value usageUTF8(args[3]);

	//	//GLenum target = std::stoi(*targetUTF8);
	//	GLuint buffer = args[0]->Uint32Value();
	//	GLintptr size = args[1]->Uint32Value();
	//	GLsizeiptr offset = args[2]->Uint32Value();
	//	GLbitfield bitfield = args[3]->Uint32Value();

	//	void* pointer = glMapNamedBufferRange(buffer, size, offset, bitfield);

	//		


	//}));

	tpl->Set(String::NewFromUtf8(isolate, "namedBufferData"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 4) {
			V8Helper::_instance->throwException("namedBufferData requires 4 argument");
			return;
		}

		String::Utf8Value bufferUTF8(args[0]);
		String::Utf8Value sizeUTF8(args[1]);
		String::Utf8Value usageUTF8(args[3]);

		int buffer = std::stoi(*bufferUTF8);
		int size = std::stoi(*sizeUTF8);
		int usage = std::stoi(*usageUTF8);

		float *data = nullptr;
		if (args[2]->IsFloat32Array()) {
			v8::Local<v8::Float32Array> view = (args[2]).As<v8::Float32Array>();

			auto buffer = view->Buffer();
			void *bdata = view->Buffer()->GetContents().Data();

			data = reinterpret_cast<float*>(bdata);

		} else {
			cout << "ERROR: array must be of type Float32Array" << endl;
			exit(1);
		}

		glNamedBufferData(buffer, size, data, usage);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "getUniformfv"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 3) {
			V8Helper::_instance->throwException("getUniformfv requires 3 arguments");
			return;
		}

		String::Utf8Value programUTF8(args[0]);
		GLuint program = std::stoul(*programUTF8);

		String::Utf8Value locationUTF8(args[1]);
		GLint location = std::stoi(*locationUTF8);


		float *params = nullptr;
		if (args[2]->IsFloat32Array()) {
			v8::Local<v8::Float32Array> view = (args[2]).As<v8::Float32Array>();
			auto buffer = view->Buffer();
			void *bdata = view->Buffer()->GetContents().Data();
			params = reinterpret_cast<float*>(bdata);
		} else {
			cout << "ERROR: array must be of type Float32Array" << endl;
			exit(1);
		}



		glGetUniformfv(program, location, params);

		// args.GetReturnValue().Set(fb);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "enableVertexAttribArray"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("enableVertexAttribArray requires 1 argument");
			return;
		}

		String::Utf8Value indexUTF8(args[0]);

		int index = std::stoi(*indexUTF8);

		glEnableVertexAttribArray(index);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "blendFunc"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 2) {
			V8Helper::_instance->throwException("blendFunc requires 2 arguments");
			return;
		}

		String::Utf8Value sfactorUTF8(args[0]);
		String::Utf8Value dfactorUTF8(args[1]);

		GLenum sfactor = std::stoi(*sfactorUTF8);
		GLenum dfactor = std::stoi(*dfactorUTF8);

		glBlendFunc(sfactor, dfactor);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "flush"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 0) {
			V8Helper::_instance->throwException("flush requires 0 arguments");
			return;
		}

		glFlush();
	}));

	tpl->Set(String::NewFromUtf8(isolate, "enable"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("enable requires 1 argument");
			return;
		}

		String::Utf8Value enumUTF8(args[0]);

		GLenum value = std::stoi(*enumUTF8);

		glEnable(value);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "disable"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("disable requires 1 argument");
			return;
		}

		String::Utf8Value enumUTF8(args[0]);

		GLenum value = std::stoi(*enumUTF8);

		glDisable(value);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "vertexAttribPointer"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 6) {
			V8Helper::_instance->throwException("vertexAttribPointer requires 6 arguments");
			return;
		}

		String::Utf8Value indexUTF8(args[0]);
		String::Utf8Value sizeUTF8(args[1]);
		String::Utf8Value typeUTF8(args[2]);
		String::Utf8Value normalizedUTF8(args[3]);
		String::Utf8Value strideUTF8(args[4]);
		String::Utf8Value pointerUTF8(args[5]);

		GLuint index = std::stoi(*indexUTF8);
		GLint size = std::stoi(*sizeUTF8);
		GLenum type = std::stoi(*typeUTF8);
		GLboolean normalized = std::stoi(*normalizedUTF8);
		GLsizei stride = std::stoi(*strideUTF8);
		int pointer = std::stoi(*pointerUTF8);

		glVertexAttribPointer(index, size, type, normalized, stride, reinterpret_cast<const void*>(pointer));
	}));

	tpl->Set(String::NewFromUtf8(isolate, "vertexAttribIPointer"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 5) {
			V8Helper::_instance->throwException("vertexAttribIPointer requires 5 arguments");
			return;
		}

		String::Utf8Value pointerUTF8(args[4]);

		GLuint index = args[0]->IntegerValue();
		GLint size = args[1]->IntegerValue();
		GLenum type = args[2]->IntegerValue();
		GLsizei stride = args[3]->IntegerValue();
		int pointer = args[4]->IntegerValue();;

		glVertexAttribIPointer(index, size, type, stride, reinterpret_cast<const void*>(pointer));
	}));

	tpl->Set(String::NewFromUtf8(isolate, "useProgram"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("useProgram requires 1 argument");
			return;
		}

		int program = args[0]->Int32Value();

		glUseProgram(program);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "memoryBarrier"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("memoryBarrier requires 1 argument");
			return;
		}

		String::Utf8Value barriersUTF8(args[0]);

		GLbitfield barriers = std::stoi(*barriersUTF8);

		glMemoryBarrier(barriers);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "bindVertexArray"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("bindVertexArray requires 1 argument");
			return;
		}

		GLuint vao = args[0]->Uint32Value();

		glBindVertexArray(vao);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "drawArrays"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 3) {
			V8Helper::_instance->throwException("drawArrays requires 3 arguments");
			return;
		}

		GLenum mode = args[0]->Uint32Value();
		GLint first = args[1]->Int32Value();
		GLsizei count = args[2]->Int32Value();

		glDrawArrays(mode, first, count);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "getProgramInfoLogString"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("drawArrays requires 1 arguments");
			return;
		}

		int program = args[0]->NumberValue();

		GLint maxLength = 0;
		glGetProgramiv(program, GL_INFO_LOG_LENGTH, &maxLength);

		// The maxLength includes the NULL character
		std::vector<GLchar> infoLog(maxLength);
		glGetProgramInfoLog(program, maxLength, &maxLength, &infoLog[0]);

		string str(infoLog.begin(), infoLog.end());

		//Local<String> v8String = String::NewFromUtf8(isolate, cppStr.c_str(), v8::String::kNormalString);
		Local<String> v8String = String::NewFromUtf8(v8::Isolate::GetCurrent(), str.c_str(), v8::String::kNormalString);

		args.GetReturnValue().Set(v8String);
		
	}));

	tpl->Set(String::NewFromUtf8(isolate, "createQuery"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 0) {
			V8Helper::_instance->throwException("createQuery requires 0 arguments");
			return;
		}

		unsigned int queryID;
		glGenQueries(1, &queryID);

		args.GetReturnValue().Set(queryID);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "deleteQuery"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("deleteQuery requires 1 arguments");
			return;
		}

		unsigned int queryID = args[0]->Uint32Value();

		glDeleteQueries(1, &queryID);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "getQueryObjectui64"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 2) {
			V8Helper::_instance->throwException("getQueryObjectui64 requires 2 arguments");
			return;
		}

		int query = args[0]->Int32Value();
		GLenum pname = args[1]->Uint32Value();

		unsigned long long params = 123;
		//glBindBuffer(GL_QUERY_BUFFER, 0);
		glGetQueryObjectui64v(query, pname, &params);

		double val = (double)params;

		args.GetReturnValue().Set(val);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "getQueryObjectui64Indirect"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 3) {
			V8Helper::_instance->throwException("getQueryObjectui64Indirect requires 3 arguments");
			return;
		}

		int query = args[0]->Int32Value();
		GLenum pname = args[1]->Uint32Value();
		uint64_t offset = args[2]->Uint32Value();

		glGetQueryObjectui64v(query, pname, (GLuint64*) + offset);

	}));

	tpl->Set(String::NewFromUtf8(isolate, "depthMask"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("depthMask requires 1 arguments");
			return;
		}

		bool mask = args[0]->BooleanValue();

		glDepthMask(mask);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "getInteger64v"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("depthMask requires 1 arguments");
			return;
		}

		GLenum target = args[0]->IntegerValue();

		GLint64 value;

		glGetInteger64v(target, &value);

		double v = value;

		args.GetReturnValue().Set(v);
	}));

	tpl->Set(String::NewFromUtf8(isolate, "exit"), FunctionTemplate::New(isolate, [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("exit requires 0 arguments");
			return;
		}

		exit(0);
	}));

	Local<Object> obj = tpl->NewInstance();

	context->Global()->Set(
		String::NewFromUtf8(isolate, "gl"),
		obj
	);



	
}


void V8Helper::setupV8() {

	V8Helper::_instance->registerFunction("acquireDesktopTexture", [](const FunctionCallbackInfo<Value>& args) {
		auto app = Application::instance();
		DesktopTexture result = app->acquireDesktopTexture();

		auto isolate = Isolate::GetCurrent();
		Local<ObjectTemplate> imgTempl = ObjectTemplate::New(isolate);
		auto object = imgTempl->NewInstance();

		auto lTextureHandle = v8::Integer::New(isolate, result.textureHandle);
		auto lHasChanged = v8::Boolean::New(isolate, result.hasChanged);

		object->Set(String::NewFromUtf8(isolate, "handle"), lTextureHandle);
		object->Set(String::NewFromUtf8(isolate, "hasChanged"), lHasChanged);

		args.GetReturnValue().Set(object);
	});

	V8Helper::_instance->registerFunction("getCursorData", [](const FunctionCallbackInfo<Value>& args) {
		auto app = Application::instance();
		MouseCursor cursor = app->getCursor();

		Local<ArrayBuffer> v8Buffer = v8::ArrayBuffer::New(Isolate::GetCurrent(), cursor.data.size());

		auto v8Data = v8Buffer->GetContents().Data();

		// TODO: load file content directly to v8 buffer to 2x allocation and a copy
		memcpy(v8Data, cursor.data.data(), cursor.data.size());

		auto isolate = Isolate::GetCurrent();
		Local<ObjectTemplate> imgTempl = ObjectTemplate::New(isolate);

		auto lwidth = v8::Integer::New(isolate, cursor.width);
		auto lheight = v8::Integer::New(isolate, cursor.height);
		auto lx = v8::Integer::New(isolate, cursor.x);
		auto ly = v8::Integer::New(isolate, cursor.y);
		auto ltype = v8::Integer::New(isolate, cursor.type);
		auto lpitch = v8::Integer::New(isolate, cursor.pitch);

		auto object = imgTempl->NewInstance();

		object->Set(String::NewFromUtf8(isolate, "width"), lwidth);
		object->Set(String::NewFromUtf8(isolate, "height"), lheight);
		object->Set(String::NewFromUtf8(isolate, "x"), lx);
		object->Set(String::NewFromUtf8(isolate, "y"), ly);
		object->Set(String::NewFromUtf8(isolate, "type"), ltype);
		object->Set(String::NewFromUtf8(isolate, "pitch"), lpitch);
		object->Set(String::NewFromUtf8(isolate, "data"), v8Buffer);

		args.GetReturnValue().Set(object);
	});

	V8Helper::_instance->registerFunction("setDebugValue", [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 2) {
			V8Helper::_instance->throwException("setDebugValue requires 2 arguments");
			return;
		}

		String::Utf8Value strKey(args[0]);
		String::Utf8Value strValue(args[1]);

		string key = *strKey;
		string value = *strValue;

		V8Helper::instance()->debugValue[key] = value;

		//cout << key << ": " << value << endl;
	});

	V8Helper::_instance->registerFunction("removeDebugValue", [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("removeDebugValue requires 1 arguments");
			return;
		}

		String::Utf8Value strKey(args[0]);

		string key = *strKey;

		V8Helper::instance()->debugValue.erase(key);

		//cout << key << ": " << value << endl;
	});

	V8Helper::_instance->registerFunction("reportState", [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("reportState requires 1 arguments");
			return;
		}

		bool reportState = args[0]->BooleanValue();

		Application::instance()->reportState = reportState;
	});

	V8Helper::_instance->registerFunction("log", [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("log requires 1 argument");
			return;
		}

		String::Utf8Value messageUTF8(args[0]);

		string message = *messageUTF8;

		cout << message << endl;
	});

	V8Helper::_instance->registerFunction("readFile", [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("readFile requires 1 arguments");
			return;
		}

		String::Utf8Value fileUTF8(args[0]);

		string file = *fileUTF8;

		vector<char> buffer = loadFile(file);

		Local<ArrayBuffer> v8Buffer = v8::ArrayBuffer::New(Isolate::GetCurrent(), buffer.size());

		auto v8Data = v8Buffer->GetContents().Data();

		// TODO: load file content directly to v8 buffer to 2x allocation and a copy
		memcpy(v8Data, buffer.data(), buffer.size());

		args.GetReturnValue().Set(v8Buffer);
	});

	V8Helper::_instance->registerFunction("loadImage", [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("loadImage requires 1 arguments");
			return;
		}

		auto isolate = Isolate::GetCurrent();

		String::Utf8Value fileUTF8(args[0]);
		string file = *fileUTF8;

		int width, height, channels;
		unsigned char *data = stbi_load(file.c_str(), &width, &height, &channels, 4);

		int size = width * height * 4;

		Local<ArrayBuffer> v8Buffer = v8::ArrayBuffer::New(Isolate::GetCurrent(), size);

		auto v8Data = v8Buffer->GetContents().Data();

		// TODO: load file content directly to v8 buffer to 2x allocation and a copy
		memcpy(v8Data, data, size);

		Local<ObjectTemplate> imgTempl = ObjectTemplate::New(isolate);

		auto lwidth = v8::Integer::New(isolate, width);
		auto lheight= v8::Integer::New(isolate, height);

		//imgTempl->Set(isolate, "width", lwidth);
		//imgTempl->Set(isolate, "height", lheight);
		//imgTempl->Set(isolate, "data", v8Buffer);

		auto object = imgTempl->NewInstance();

		object->Set(String::NewFromUtf8(isolate, "width"), lwidth);
		object->Set(String::NewFromUtf8(isolate, "height"), lheight);
		object->Set(String::NewFromUtf8(isolate, "data"), v8Buffer);


		args.GetReturnValue().Set(object);
	});

	

	V8Helper::_instance->registerFunction("readTextFile", [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("readFile requires 1 arguments");
			return;
		}

		String::Utf8Value fileUTF8(args[0]);

		string file = *fileUTF8;

		// see https://stackoverflow.com/questions/2602013/read-whole-ascii-file-into-c-stdstring
		std::ifstream t(file);
		std::stringstream buffer;
		buffer << t.rdbuf();
		string text = buffer.str();

		auto v8str = v8::String::NewFromUtf8(Isolate::GetCurrent(), text.c_str());

		args.GetReturnValue().Set(v8str);
	});

	V8Helper::_instance->registerFunction("writeTextFile", [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 2) {
			V8Helper::_instance->throwException("writeTextFile requires 2 arguments");
			return;
		}

		String::Utf8Value fileUTF8(args[0]);
		string file = *fileUTF8;

		String::Utf8Value textUTF8(args[1]);
		string text = *textUTF8;

		// see https://stackoverflow.com/questions/2602013/read-whole-ascii-file-into-c-stdstring
		std::ofstream t(file);

		t << text;

		t.close();


		//std::stringstream buffer;
		//buffer << t.rdbuf();
		//string text = buffer.str();

		//auto v8str = v8::String::NewFromUtf8(Isolate::GetCurrent(), text.c_str());

		//args.GetReturnValue().Set(v8str);
	});

	V8Helper::_instance->registerFunction("openFile", [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("openFile requires 1 arguments");
			return;
		}

		String::Utf8Value vsSourceUTF8(args[0]);

		string path = *vsSourceUTF8;

		if (fs::exists(path)) {
			File *file = new File(path);
			auto v8File = v8Object(file);

			//auto programID = shader->program;
			args.GetReturnValue().Set(v8File);
		} else {
			//args.GetReturnValue().Set(v8::Null);
		}
	});

	V8Helper::_instance->registerFunction("monitorFile", [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 2) {
			V8Helper::_instance->throwException("monitorFile requires 2 arguments");
			return;
		}

		String::Utf8Value fileUTF8(args[0]);
		string file = *fileUTF8;

		Local<Value> callbackValue = args[1];
		Local<Function> callback = Local<Function>::Cast(callbackValue);

		auto isolate = Isolate::GetCurrent();
		auto persistent = PersistentFunction(isolate, callback);

		monitorFile(file, [isolate, persistent]() {
			
			Local<Function> local = Local<Function>::New(isolate, persistent);

			int argc = 0;
			Local<Value> argv[1];
			
			local->Call(local, argc, argv);

		});

		//auto programID = shader->program;
		//args.GetReturnValue().Set(v8Shader);
	});

	V8Helper::_instance->registerFunction("watchShader", [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 2) {
			V8Helper::_instance->throwException("watchShader requires 2 arguments");
			return;
		}

		String::Utf8Value vsSourceUTF8(args[0]);
		String::Utf8Value fsSourceUTF8(args[1]);

		string vsSource = *vsSourceUTF8;
		string fsSource = *fsSourceUTF8;

		Shader *shader = new Shader(vsSource, fsSource);
		auto v8Shader = v8Object(shader);

		monitorFile(vsSource, [shader]() {
			shader->compile();
		});

		monitorFile(fsSource, [shader]() {
			shader->compile();
		});

		//auto programID = shader->program;
		args.GetReturnValue().Set(v8Shader);
	});

	V8Helper::_instance->registerFunction("watchComputeShader", [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("watchComputeShader requires 1 argument");
			return;
		}

		String::Utf8Value csSourceUTF8(args[0]);

		string csSource = *csSourceUTF8;

		ComputeShader *shader = new ComputeShader(csSource);
		auto v8Shader = v8Object(shader);

		monitorFile(csSource, [shader]() {
			shader->compile();
		});

		args.GetReturnValue().Set(v8Shader);
	});

	V8Helper::_instance->registerFunction("watchJS", [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("watchJS requires 1 argument");
			return;
		}

		String::Utf8Value jsSourceUTF8(args[0]);

		string jsSource = *jsSourceUTF8;

		string code = loadFileAsString(jsSource);
		V8Helper::instance()->runScriptSilent(code);

		monitorFile(jsSource, [jsSource]() {
			string code = loadFileAsString(jsSource);
			V8Helper::instance()->runScriptSilent(code);
		});
	});

	V8Helper::_instance->registerFunction("monitorJS", [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("monitorJS requires 1 argument");
			return;
		}

		String::Utf8Value jsSourceUTF8(args[0]);

		string jsSource = *jsSourceUTF8;

		//string code = loadFileAsString(jsSource);
		//V8Helper::instance()->runScriptSilent(code);

		monitorFile(jsSource, [jsSource]() {
			string code = loadFileAsString(jsSource);
			V8Helper::instance()->runScriptSilent(code);
		});
	});

	V8Helper::_instance->registerFunction("runJSFile", [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("runJSFile requires 1 argument");
			return;
		}

		String::Utf8Value jsSourceUTF8(args[0]);

		string jsSource = *jsSourceUTF8;

		string code = loadFileAsString(jsSource);

		V8Helper::instance()->runScript(code);
	});

	//V8Helper::_instance->registerFunction("test", [](const FunctionCallbackInfo<Value>& args) {
	//	if (args.Length() != 0) {
	//		V8Helper::_instance->throwException("test requires 0 arguments");
	//		return;
	//	}

	//	string path = "C:/dev/pointclouds/eclepens.las";
	//	LASLoaderThreaded::LASLoader *loader = new LASLoaderThreaded::LASLoader(path);

	//	GLuint vboHandle;
	//	glCreateBuffers(1, &vboHandle);

	//	int numBytes = loader->header.numPoints * 16;
	//	//glNamedBufferData(vboHandle, numBytes, nullptr, GL_DYNAMIC_DRAW);
	//	GLbitfield storageFlags = GL_MAP_WRITE_BIT | GL_MAP_PERSISTENT_BIT;
	//	glNamedBufferStorage(vboHandle, numBytes, nullptr, storageFlags);

	//	GLbitfield mapFlags = GL_MAP_UNSYNCHRONIZED_BIT | GL_MAP_WRITE_BIT | GL_MAP_FLUSH_EXPLICIT_BIT | GL_MAP_PERSISTENT_BIT;
	//	void* mapptr = glMapNamedBufferRange(vboHandle, 0, numBytes, mapFlags);
	//	//void* mapptr = glMapNamedBuffer(vboHandle, numBytes, flags);

	//	//thread t([loader, vboHandle]() {
	//	thread t([loader, vboHandle, mapptr]() {

	//		int offset = 0;

	//		std::this_thread::sleep_for(std::chrono::milliseconds(1000));

	//		while (!loader->allChunksServed()) {

	//			std::this_thread::sleep_for(std::chrono::milliseconds(10));

	//			if (loader->hasChunkAvailable()) {
	//				auto chunk = loader->getNextChunk();

	//				float *dataF32 = reinterpret_cast<float*>(mapptr);
	//				//float *dataF32 = new float[chunk.size * 4];
	//				uint32_t *dataU32 = reinterpret_cast<uint32_t*>(dataF32);

	//				uint32_t* dataChunkRGBA = reinterpret_cast<uint32_t*>(chunk.rgba.data());

	//				for (int i = 0; i < chunk.size; i++) {
	//					dataF32[4 * i + 0] = chunk.position[3 * i + 0];
	//					dataF32[4 * i + 1] = chunk.position[3 * i + 1];
	//					dataF32[4 * i + 2] = chunk.position[3 * i + 2];
	//					dataU32[4 * i + 3] = dataChunkRGBA[i];
	//					
	//				}

	//				schedule([vboHandle, chunk, offset, dataF32, mapptr]() {
	//					auto threadID = std::this_thread::get_id();
	//					cout << "handling chunk in thread: " << threadID << endl;

	//					int numBytes = chunk.size * 16;

	//					glFlushMappedNamedBufferRange(vboHandle, offset, numBytes);

	//					//GLuint vboHandle;
	//					//glCreateBuffers(1, &vboHandle);
	//					
	//					//glNamedBufferData(vboHandle, numBytes, nullptr, GL_DYNAMIC_DRAW);
	//					//glNamedBufferData(vboHandle, numBytes, nullptr, GL_DYNAMIC_DRAW);

	//					int chunkSizeBytes = chunk.size * 16;
	//					const void *data = reinterpret_cast<const void*>(dataF32);
	//					//glNamedBufferSubData(vboHandle, offset, chunkSizeBytes, data);
	//					//glNamedBufferData(vboHandle, numBytes, nullptr, GL_DYNAMIC_DRAW);
	//					//glNamedBufferData(vboHandle, numBytes, data, GL_DYNAMIC_DRAW);

	//					

	//					//auto start = now();
	//					//memcpy(mapptr, reinterpret_cast<void*>(dataF32), chunkSizeBytes);
	//					//auto end = now();
	//					//auto duration = end - start;
	//					//cout << "duration memcpy: " << duration << endl;

	//					//glFlushMappedNamedBufferRange(vboHandle, offset, chunkSizeBytes);
	//					//glUnmapNamedBuffer(vboHandle);
	//				});

	//				offset += chunk.size * 16;

	//				cout << "new chunk available, size: " << chunk.size << endl;

	//				return;
	//			}

	//		}
	//	});
	//	t.detach();
	//	

	//});

	V8Helper::_instance->registerFunction("now", [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 0) {
			V8Helper::_instance->throwException("now requires 0 arguments");
			return;
		}

		auto now = std::chrono::high_resolution_clock::now();
		long long nanosSinceStart = now.time_since_epoch().count() - start_time;

		double secondsSinceStart = double(nanosSinceStart) / 1'000'000'000;

		args.GetReturnValue().Set(secondsSinceStart);
	});

	typedef Persistent<Promise::Resolver, CopyablePersistentTraits<Promise::Resolver>> PersistentResolver;
	static unordered_map<long long, PersistentResolver> resolvers;
	static long long resolverID = 0;

	V8Helper::_instance->registerFunction("readFileAsync", [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 1) {
			V8Helper::_instance->throwException("readFileAsync requires 1 arguments");
			return;
		}
		auto isolate = Isolate::GetCurrent();

		String::Utf8Value fileUTF8(args[0]);

		string file = *fileUTF8;

		Local<Promise::Resolver> resolver = v8::Promise::Resolver::New(isolate);

		long long currentID = resolverID++;
		resolvers[currentID] = PersistentResolver(isolate, resolver);

		thread t([file, isolate, currentID](){

			vector<char> buffer = loadFile(file);

			schedule([currentID, isolate, buffer/*, startThread*/]() {
				Local<ArrayBuffer> v8Buffer = v8::ArrayBuffer::New(Isolate::GetCurrent(), buffer.size());
		
				auto v8Data = v8Buffer->GetContents().Data();
		
				// TODO: load file content directly to v8 buffer to avoid 2x allocation and a copy
				memcpy(v8Data, buffer.data(), buffer.size());

				auto persistantResolver = resolvers[currentID];
				Local<Promise::Resolver> resolver = Local<Promise::Resolver>::New(isolate, persistantResolver);

				resolver->Resolve(v8Buffer);

				resolvers.erase(currentID);
			});
			
		}); 
		t.detach();

		args.GetReturnValue().Set(resolver->GetPromise());

	});

	//V8Helper::_instance->registerFunction("writeState", [](const FunctionCallbackInfo<Value>& args) {
	//	if (args.Length() != 0) {
	//		V8Helper::_instance->throwException("writeState requires 0 arguments");
	//		return;
	//	}
	//
	//	auto isolate = Isolate::GetCurrent();
	//	
	//	thread t([isolate]() {
	//		string text = "abc";
	//		string path = "./state.html";
	//
	//		std::ofstream file;
	//		file.open(path);
	//
	//		file << text << endl;
	//
	//		file.close();
	//
	//	});
	//		
	//	t.detach();
	//
	//});


	struct IPoint {
		int ux;
		int uy;
		int uz;
		unsigned char r;
		unsigned char g;
		unsigned char b;
		unsigned char a;
	};

	struct OPoint {
		float x;
		float y;
		float z;
		unsigned char r;
		unsigned char g;
		unsigned char b;
		unsigned char a;
	};

	V8Helper::_instance->registerFunction("loadNodeAsync", [](const FunctionCallbackInfo<Value>& args) {
		if (args.Length() != 5) {
			V8Helper::_instance->throwException("loadNodeAsync requires 5 arguments");
			return;
		}

		auto isolate = Isolate::GetCurrent();

		String::Utf8Value fileUTF8(args[0]);

		string file = *fileUTF8;
		float scale = args[1]->NumberValue();
		float minX = args[2]->NumberValue();
		float minY = args[3]->NumberValue();
		float minZ = args[4]->NumberValue();

		Local<Promise::Resolver> resolver = v8::Promise::Resolver::New(isolate);

		long long currentID = resolverID++;
		resolvers[currentID] = PersistentResolver(isolate, resolver);

		thread t([file, scale, minX, minY, minZ, isolate, currentID]() {

			vector<char> buffer = loadFile(file);
			int numPoints = buffer.size() / 16;

			IPoint *source = reinterpret_cast<IPoint*>(buffer.data());
			vector<OPoint> target = vector<OPoint>();
			target.reserve(numPoints);

			for (int i = 0; i < numPoints; i++) {
				IPoint s = source[i];
				OPoint t;

				t.x = s.ux * scale + minX;
				t.y = s.uy * scale + minY;
				t.z = s.uz * scale + minZ;

				t.r = s.r;
				t.g = s.g;
				t.b = s.b;
				t.a = 255;

				target.push_back(t);
			}








			schedule([currentID, isolate, target/*, startThread*/]() {
				Local<ArrayBuffer> v8Buffer = v8::ArrayBuffer::New(Isolate::GetCurrent(), target.size() * sizeof(OPoint));

				auto v8Data = v8Buffer->GetContents().Data();

				// TODO: load file content directly to v8 buffer to avoid 2x allocation and a copy
				memcpy(v8Data, target.data(), target.size() * sizeof(OPoint));

				auto persistantResolver = resolvers[currentID];
				Local<Promise::Resolver> resolver = Local<Promise::Resolver>::New(isolate, persistantResolver);

				resolver->Resolve(v8Buffer);

				resolvers.erase(currentID);
			});

		});
		t.detach();

		args.GetReturnValue().Set(resolver->GetPromise());

	});


	setupWindow();
	setupGL();
	setupVR();

}